!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t(require("Cesium")) : "function" == typeof define && define.amd ? define(["Cesium"], t) : "object" == typeof exports ? exports.wind = t(require("Cesium")) : e.wind = t(e.Cesium) }("undefined" != typeof self ? self : this, function (e) { return function (e) { function t(n) { if (r[n]) return r[n].exports; var i = r[n] = { i: n, l: !1, exports: {} }; return e[n].call(i.exports, i, i.exports, t), i.l = !0, i.exports } var r = {}; return t.m = e, t.c = r, t.d = function (e, r, n) { t.o(e, r) || Object.defineProperty(e, r, { configurable: !1, enumerable: !0, get: n }) }, t.n = function (e) { var r = e && e.__esModule ? function () { return e.default } : function () { return e }; return t.d(r, "a", r), r }, t.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, t.p = "", t(t.s = 3) }([function (t, r) { t.exports = e }, function (e, t, r) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.Util = void 0; var n = r(0), i = function (e) { return e && e.__esModule ? e : { default: e } }(n); t.Util = function () { return { getFullscreenQuad: function () { return new i.default.Geometry({ attributes: new i.default.GeometryAttributes({ position: new i.default.GeometryAttribute({ componentDatatype: i.default.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0]) }), st: new i.default.GeometryAttribute({ componentDatatype: i.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]) }) }), indices: new Uint32Array([3, 2, 0, 0, 2, 1]) }) }, createTexture: function (e, t) { if (i.default.defined(t)) { var r = {}; r.arrayBufferView = t, e.source = r } return new i.default.Texture(e) }, createFramebuffer: function (e, t, r) { return new i.default.Framebuffer({ context: e, colorTextures: [t], depthTexture: r }) }, createRawRenderState: function (e) { var t = { viewport: e.viewport, depthTest: e.depthTest, depthMask: e.depthMask, blending: e.blending }; return i.default.Appearance.getDefaultRenderState(!0, !1, t) }, viewRectangleToLonLatRange: function (e) { var t, r, n = {}, a = i.default.Math.mod(e.west, i.default.Math.TWO_PI), o = i.default.Math.mod(e.east, i.default.Math.TWO_PI), s = e.width; s > i.default.Math.THREE_PI_OVER_TWO ? (t = 0, r = i.default.Math.TWO_PI) : o - a < s ? (t = a, r = a + s) : (t = a, r = o), n.lon = { min: i.default.Math.toDegrees(t), max: i.default.Math.toDegrees(r) }; var u = e.south, l = e.north, c = e.height, d = c > i.default.Math.PI / 12 ? c / 2 : 0, f = i.default.Math.clampToLatitudeRange(u - d), p = i.default.Math.clampToLatitudeRange(l + d); return f < -i.default.Math.PI_OVER_THREE && (f = -i.default.Math.PI_OVER_TWO), p > i.default.Math.PI_OVER_THREE && (p = i.default.Math.PI_OVER_TWO), n.lat = { min: i.default.Math.toDegrees(f), max: i.default.Math.toDegrees(p) }, n } } }() }, function (e, t, r) { "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }), t.CustomPrimitive = void 0; var i = function () { function e(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, r, n) { return r && e(t.prototype, r), n && e(t, n), t } }(), a = r(0), o = function (e) { return e && e.__esModule ? e : { default: e } }(a); t.CustomPrimitive = function () { function e(t) { n(this, e), this.commandType = t.commandType, this.geometry = t.geometry, this.attributeLocations = t.attributeLocations, this.primitiveType = t.primitiveType, this.uniformMap = t.uniformMap, this.vertexShaderSource = t.vertexShaderSource, this.fragmentShaderSource = t.fragmentShaderSource, this.rawRenderState = t.rawRenderState, this.framebuffer = t.framebuffer, this.outputTexture = t.outputTexture, this.autoClear = o.default.defaultValue(t.autoClear, !1), this.preExecute = t.preExecute, this.show = !0, this.commandToExecute = void 0, this.clearCommand = void 0, this.autoClear && (this.clearCommand = new o.default.ClearCommand({ color: new o.default.Color(0, 0, 0, 0), depth: 1, framebuffer: this.framebuffer, pass: o.default.Pass.OPAQUE })) } return i(e, [{ key: "createCommand", value: function (e) { switch (this.commandType) { case "Draw": var t = o.default.VertexArray.fromGeometry({ context: e, geometry: this.geometry, attributeLocations: this.attributeLocations, bufferUsage: o.default.BufferUsage.STATIC_DRAW }), r = o.default.ShaderProgram.fromCache({ context: e, attributeLocations: this.attributeLocations, vertexShaderSource: this.vertexShaderSource, fragmentShaderSource: this.fragmentShaderSource }), n = o.default.RenderState.fromCache(this.rawRenderState); return new o.default.DrawCommand({ owner: this, vertexArray: t, primitiveType: this.primitiveType, uniformMap: this.uniformMap, modelMatrix: o.default.Matrix4.IDENTITY, shaderProgram: r, framebuffer: this.framebuffer, renderState: n, pass: o.default.Pass.OPAQUE }); case "Compute": return new o.default.ComputeCommand({ owner: this, fragmentShaderSource: this.fragmentShaderSource, uniformMap: this.uniformMap, outputTexture: this.outputTexture, persists: !0 }) } } }, { key: "setGeometry", value: function (e, t) { this.geometry = t; var r = o.default.VertexArray.fromGeometry({ context: e, geometry: this.geometry, attributeLocations: this.attributeLocations, bufferUsage: o.default.BufferUsage.STATIC_DRAW }); this.commandToExecute.vertexArray = r } }, { key: "update", value: function (e) { this.show && (o.default.defined(this.commandToExecute) || (this.commandToExecute = this.createCommand(e.context)), o.default.defined(this.preExecute) && this.preExecute(), o.default.defined(this.clearCommand) && e.commandList.push(this.clearCommand), e.commandList.push(this.commandToExecute)) } }, { key: "isDestroyed", value: function () { return !1 } }, { key: "destroy", value: function () { return o.default.defined(this.commandToExecute) && (this.commandToExecute.shaderProgram = this.commandToExecute.shaderProgram && this.commandToExecute.shaderProgram.destroy()), o.default.destroyObject(this) } }]), e }() }, function (e, t, r) { "use strict"; var n = r(4); window.mars3d || console.log("请首先引入 cesium-mars 基础库，才能使用该插件！ http://www.dehui.info"), mars3d.Wind = n.Wind }, function (e, t, r) { "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }), t.Wind = void 0; var i = function () { function e(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, r, n) { return r && e(t.prototype, r), n && e(t, n), t } }(), a = r(0), o = function (e) { return e && e.__esModule ? e : { default: e } }(a), s = r(5), u = r(1), l = { maxParticles: 16384, particleHeight: 100, fadeOpacity: .996, dropRate: .003, dropRateBump: .01, speedFactor: 4, lineWidth: 4 }; t.Wind = function () { function e(t, r) { if (n(this, e), this.viewer = t, this.scene = this.viewer.scene, this.camera = this.viewer.camera, this.primitives = new o.default.PrimitiveCollection, this.viewer.scene.primitives.add(this.primitives), this.maxParticles = l.maxParticles, this.particleHeight = l.particleHeight, this.fadeOpacity = l.fadeOpacity, this.dropRate = l.dropRate, this.dropRateBump = l.dropRateBump, this.speedFactor = l.speedFactor, this.lineWidth = l.lineWidth, r) for (var i in r) this[i] = r[i]; this.viewerParameters = { lonRange: new o.default.Cartesian2, latRange: new o.default.Cartesian2, pixelSize: 0 }, this.globeBoundingSphere = new o.default.BoundingSphere(o.default.Cartesian3.ZERO, 6314355.63), this.updateViewerParameters() } return i(e, [{ key: "setData", value: function (e) { this.particleSystem = new s.ParticleSystem(this.scene.context, e, this.getUserInput(), this.viewerParameters), this.addPrimitives(), this.setupEventListeners() } }, { key: "updateParticleSystemOptions", value: function (e) { if (e) for (var t in e) this[t] = e[t]; this.particleSystem.applyUserInput(this.getUserInput()) } }, { key: "getUserInput", value: function () { var e = Math.ceil(Math.sqrt(this.maxParticles)); return this.maxParticles = e * e, { particlesTextureSize: e, maxParticles: this.maxParticles, particleHeight: this.particleHeight, fadeOpacity: this.fadeOpacity, dropRate: this.dropRate, dropRateBump: this.dropRateBump, speedFactor: this.speedFactor, lineWidth: this.lineWidth, globeLayer: this.globeLayer, WMS_URL: this.WMS_URL } } }, { key: "addPrimitives", value: function () { this.primitives.add(this.particleSystem.particlesComputing.primitives.getWind), this.primitives.add(this.particleSystem.particlesComputing.primitives.updateSpeed), this.primitives.add(this.particleSystem.particlesComputing.primitives.updatePosition), this.primitives.add(this.particleSystem.particlesComputing.primitives.postProcessingPosition), this.primitives.add(this.particleSystem.particlesComputing.primitives.postProcessingSpeed), this.primitives.add(this.particleSystem.particlesRendering.primitives.segments), this.primitives.add(this.particleSystem.particlesRendering.primitives.trails), this.primitives.add(this.particleSystem.particlesRendering.primitives.screen) } }, { key: "updateViewerParameters", value: function () { var e = this.camera.computeViewRectangle(this.scene.globe.ellipsoid), t = u.Util.viewRectangleToLonLatRange(e); this.viewerParameters.lonRange.x = t.lon.min, this.viewerParameters.lonRange.y = t.lon.max, this.viewerParameters.latRange.x = t.lat.min, this.viewerParameters.latRange.y = t.lat.max; var r = this.camera.getPixelSize(this.globeBoundingSphere, this.scene.drawingBufferWidth, this.scene.drawingBufferHeight); r > 0 && (this.viewerParameters.pixelSize = r) } }, { key: "setupEventListeners", value: function () { var e = this; this.camera.moveStart.addEventListener(function () { e._isDestroy || (e.primitives.show = !1) }), this.camera.moveEnd.addEventListener(function () { e._isDestroy || (e.updateViewerParameters(), e.particleSystem.applyViewerParameters(e.viewerParameters), e.primitives.show = !0) }); var t = !1; window.addEventListener("resize", function () { e._isDestroy || (t = !0, e.primitives.show = !1, e.primitives.removeAll()) }), this.scene.preRender.addEventListener(function () { e._isDestroy || t && (e.particleSystem.canvasResize(e.scene.context), t = !1, e.addPrimitives(), e.primitives.show = !0) }) } }, { key: "destroy", value: function () { this._isDestroy = !0, this.primitives.removeAll(), this.viewer.scene.primitives.remove(this.primitives) } }]), e }() }, function (e, t, r) { "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }), t.ParticleSystem = void 0; var i = function () { function e(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, r, n) { return r && e(t.prototype, r), n && e(t, n), t } }(), a = r(0), o = function (e) { return e && e.__esModule ? e : { default: e } }(a), s = r(6), u = r(12); t.ParticleSystem = function () { function e(t, r, i, a) { n(this, e), this.context = t, this.data = r, this.userInput = i, this.viewerParameters = a, this.particlesComputing = new u.ParticlesComputing(this.context, this.data, this.userInput, this.viewerParameters), this.particlesRendering = new s.ParticlesRendering(this.context, this.data, this.userInput, this.viewerParameters, this.particlesComputing) } return i(e, [{ key: "canvasResize", value: function (e) { var t = this; this.particlesComputing.destroyParticlesTextures(), Object.keys(this.particlesComputing.windTextures).forEach(function (e) { t.particlesComputing.windTextures[e].destroy() }), this.particlesRendering.textures.colorTable.destroy(), Object.keys(this.particlesRendering.framebuffers).forEach(function (e) { t.particlesRendering.framebuffers[e].destroy() }), this.context = e, this.particlesComputing = new u.ParticlesComputing(this.context, this.data, this.userInput, this.viewerParameters), this.particlesRendering = new s.ParticlesRendering(this.context, this.data, this.userInput, this.viewerParameters, this.particlesComputing) } }, { key: "clearFramebuffers", value: function () { var e = this, t = new o.default.ClearCommand({ color: new o.default.Color(0, 0, 0, 0), depth: 1, framebuffer: void 0, pass: o.default.Pass.OPAQUE }); Object.keys(this.particlesRendering.framebuffers).forEach(function (r) { t.framebuffer = e.particlesRendering.framebuffers[r], t.execute(e.context) }) } }, { key: "refreshParticles", value: function (e) { if (this.clearFramebuffers(), this.particlesComputing.destroyParticlesTextures(), this.particlesComputing.createParticlesTextures(this.context, this.userInput, this.viewerParameters), e) { var t = this.particlesRendering.createSegmentsGeometry(this.userInput); this.particlesRendering.primitives.segments.geometry = t; var r = o.default.VertexArray.fromGeometry({ context: this.context, geometry: t, attributeLocations: this.particlesRendering.primitives.segments.attributeLocations, bufferUsage: o.default.BufferUsage.STATIC_DRAW }); this.particlesRendering.primitives.segments.commandToExecute.vertexArray = r } } }, { key: "applyUserInput", value: function (e) { var t = this, r = !1; this.userInput.maxParticles != e.maxParticles && (r = !0), Object.keys(e).forEach(function (r) { t.userInput[r] = e[r] }), this.refreshParticles(r) } }, { key: "applyViewerParameters", value: function (e) { var t = this; Object.keys(e).forEach(function (r) { t.viewerParameters[r] = e[r] }), this.refreshParticles(!1) } }]), e }() }, function (e, t, r) { "use strict"; function n(e) { return e && e.__esModule ? e : { default: e } } function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }), t.ParticlesRendering = void 0; var a = function () { function e(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, r, n) { return r && e(t.prototype, r), n && e(t, n), t } }(), o = r(0), s = n(o), u = r(2), l = r(1), c = r(7), d = n(c), f = r(8), p = n(f), m = r(9), v = n(m), x = r(10), h = n(x), g = r(11), P = n(g); t.ParticlesRendering = function () { function e(t, r, n, a, o) { i(this, e), this.createRenderingTextures(t, r), this.createRenderingFramebuffers(t), this.createRenderingPrimitives(t, n, a, o) } return a(e, [{ key: "createRenderingTextures", value: function (e, t) { var r = { context: e, width: e.drawingBufferWidth, height: e.drawingBufferHeight, pixelFormat: s.default.PixelFormat.RGBA, pixelDatatype: s.default.PixelDatatype.UNSIGNED_BYTE }, n = { context: e, width: e.drawingBufferWidth, height: e.drawingBufferHeight, pixelFormat: s.default.PixelFormat.DEPTH_COMPONENT, pixelDatatype: s.default.PixelDatatype.UNSIGNED_INT }, i = { context: e, width: t.colorTable.colorNum, height: 1, pixelFormat: s.default.PixelFormat.RGB, pixelDatatype: s.default.PixelDatatype.FLOAT, sampler: new s.default.Sampler({ minificationFilter: s.default.TextureMinificationFilter.LINEAR, magnificationFilter: s.default.TextureMagnificationFilter.LINEAR }) }; this.textures = { segmentsColor: l.Util.createTexture(r), segmentsDepth: l.Util.createTexture(n), currentTrailsColor: l.Util.createTexture(r), currentTrailsDepth: l.Util.createTexture(n), nextTrailsColor: l.Util.createTexture(r), nextTrailsDepth: l.Util.createTexture(n), colorTable: l.Util.createTexture(i, t.colorTable.array) } } }, { key: "createRenderingFramebuffers", value: function (e) { this.framebuffers = { segments: l.Util.createFramebuffer(e, this.textures.segmentsColor, this.textures.segmentsDepth), currentTrails: l.Util.createFramebuffer(e, this.textures.currentTrailsColor, this.textures.currentTrailsDepth), nextTrails: l.Util.createFramebuffer(e, this.textures.nextTrailsColor, this.textures.nextTrailsDepth) } } }, { key: "createSegmentsGeometry", value: function (e) { for (var t = [], r = 0; r < e.particlesTextureSize; r++)for (var n = 0; n < e.particlesTextureSize; n++)for (var i = 0; i < 4; i++)t.push(r / e.particlesTextureSize), t.push(n / e.particlesTextureSize); t = new Float32Array(t); for (var a = [], o = [-1, 1], u = [-1, 1], i = 0; i < e.maxParticles; i++)for (var l = 0; l < 2; l++)for (var c = 0; c < 2; c++)a.push(o[l]), a.push(u[c]), a.push(0); a = new Float32Array(a); for (var d = 6 * e.maxParticles, f = new Uint32Array(d), i = 0, l = 0, p = 0; i < e.maxParticles; i++)f[l++] = p + 0, f[l++] = p + 1, f[l++] = p + 2, f[l++] = p + 2, f[l++] = p + 1, f[l++] = p + 3, p += 4; return new s.default.Geometry({ attributes: new s.default.GeometryAttributes({ st: new s.default.GeometryAttribute({ componentDatatype: s.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: t }), normal: new s.default.GeometryAttribute({ componentDatatype: s.default.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: a }) }), indices: f }) } }, { key: "createRenderingPrimitives", value: function (e, t, r, n) { var i = this; this.primitives = { segments: new u.CustomPrimitive({ commandType: "Draw", attributeLocations: { st: 0, normal: 1 }, geometry: this.createSegmentsGeometry(t), primitiveType: s.default.PrimitiveType.TRIANGLES, uniformMap: { currentParticlesPosition: function () { return n.particlesTextures.currentParticlesPosition }, postProcessingPosition: function () { return n.particlesTextures.postProcessingPosition }, postProcessingSpeed: function () { return n.particlesTextures.postProcessingSpeed }, colorTable: function () { return i.textures.colorTable }, aspect: function () { return e.drawingBufferWidth / e.drawingBufferHeight }, pixelSize: function () { return r.pixelSize }, lineWidth: function () { return t.lineWidth }, particleHeight: function () { return t.particleHeight } }, vertexShaderSource: new s.default.ShaderSource({ sources: [d.default] }), fragmentShaderSource: new s.default.ShaderSource({ sources: [p.default] }), rawRenderState: l.Util.createRawRenderState({ viewport: void 0, depthTest: { enabled: !0 }, depthMask: !0 }), framebuffer: this.framebuffers.segments, autoClear: !0 }), trails: new u.CustomPrimitive({ commandType: "Draw", attributeLocations: { position: 0, st: 1 }, geometry: l.Util.getFullscreenQuad(), primitiveType: s.default.PrimitiveType.TRIANGLES, uniformMap: { segmentsColorTexture: function () { return i.textures.segmentsColor }, segmentsDepthTexture: function () { return i.textures.segmentsDepth }, currentTrailsColor: function () { return i.framebuffers.currentTrails.getColorTexture(0) }, trailsDepthTexture: function () { return i.framebuffers.currentTrails.depthTexture }, fadeOpacity: function () { return t.fadeOpacity } }, vertexShaderSource: new s.default.ShaderSource({ defines: ["DISABLE_GL_POSITION_LOG_DEPTH"], sources: [v.default] }), fragmentShaderSource: new s.default.ShaderSource({ defines: ["DISABLE_LOG_DEPTH_FRAGMENT_WRITE"], sources: [h.default] }), rawRenderState: l.Util.createRawRenderState({ viewport: void 0, depthTest: { enabled: !0, func: s.default.DepthFunction.ALWAYS }, depthMask: !0 }), framebuffer: this.framebuffers.nextTrails, autoClear: !0, preExecute: function () { var e; e = i.framebuffers.currentTrails, i.framebuffers.currentTrails = i.framebuffers.nextTrails, i.framebuffers.nextTrails = e, i.primitives.trails.commandToExecute.framebuffer = i.framebuffers.nextTrails, i.primitives.trails.clearCommand.framebuffer = i.framebuffers.nextTrails } }), screen: new u.CustomPrimitive({ commandType: "Draw", attributeLocations: { position: 0, st: 1 }, geometry: l.Util.getFullscreenQuad(), primitiveType: s.default.PrimitiveType.TRIANGLES, uniformMap: { trailsColorTexture: function () { return i.framebuffers.nextTrails.getColorTexture(0) }, trailsDepthTexture: function () { return i.framebuffers.nextTrails.depthTexture } }, vertexShaderSource: new s.default.ShaderSource({ defines: ["DISABLE_GL_POSITION_LOG_DEPTH"], sources: [v.default] }), fragmentShaderSource: new s.default.ShaderSource({ defines: ["DISABLE_LOG_DEPTH_FRAGMENT_WRITE"], sources: [P.default] }), rawRenderState: l.Util.createRawRenderState({ viewport: void 0, depthTest: { enabled: !1 }, depthMask: !0, blending: { enabled: !0 } }), framebuffer: void 0 }) } } }]), e }() }, function (e, t) { e.exports = "attribute vec2 st;\r\n// it is not normal itself, but used to control normal\r\nattribute vec3 normal; // (point to use, offset sign, not used component)\r\n\r\nuniform sampler2D currentParticlesPosition;\r\nuniform sampler2D postProcessingPosition;\r\nuniform sampler2D postProcessingSpeed;\r\n\r\nuniform float particleHeight;\r\n\r\nuniform float aspect;\r\nuniform float pixelSize;\r\nuniform float lineWidth;\r\n\r\nvarying float speedNormalization;\r\n\r\nvec3 convertCoordinate(vec3 lonLatLev) {\r\n    // WGS84 (lon, lat, lev) -> ECEF (x, y, z)\r\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates for detail\r\n\t\r\n    // WGS 84 geometric constants \r\n    float a = 6378137.0; // Semi-major axis \r\n    float b = 6356752.3142; // Semi-minor axis \r\n    float e2 = 6.69437999014e-3; // First eccentricity squared\r\n\r\n    float latitude = radians(lonLatLev.y);\r\n    float longitude = radians(lonLatLev.x);\r\n\r\n    float cosLat = cos(latitude);\r\n    float sinLat = sin(latitude);\r\n    float cosLon = cos(longitude);\r\n    float sinLon = sin(longitude);\r\n\r\n    float N_Phi = a / sqrt(1.0 - e2 * sinLat * sinLat);\r\n    float h = particleHeight; // it should be high enough otherwise the particle may not pass the terrain depth test\r\n\r\n    vec3 cartesian = vec3(0.0);\r\n    cartesian.x = (N_Phi + h) * cosLat * cosLon;\r\n    cartesian.y = (N_Phi + h) * cosLat * sinLon;\r\n    cartesian.z = ((b * b) / (a * a) * N_Phi + h) * sinLat;\r\n    return cartesian;\r\n}\r\n\r\nvec4 calcProjectedCoord(vec3 lonLatLev) {\r\n    // the range of longitude in Cesium is [-180, 180] but the range of longitude in the NetCDF file is [0, 360]\r\n    // [0, 180] is corresponding to [0, 180] and [180, 360] is corresponding to [-180, 0]\r\n    lonLatLev.x = mod(lonLatLev.x + 180.0, 360.0) - 180.0;\r\n    vec3 particlePosition = convertCoordinate(lonLatLev);\r\n    vec4 projectedCoord = czm_modelViewProjection * vec4(particlePosition, 1.0);\r\n    return projectedCoord;\r\n}\r\n\r\nvec4 calcOffset(vec4 currentProjectedCoord, vec4 nextProjectedCoord, float offsetSign) {\r\n    vec2 aspectVec2 = vec2(aspect, 1.0);\r\n    vec2 currentXY = (currentProjectedCoord.xy / currentProjectedCoord.w) * aspectVec2;\r\n    vec2 nextXY = (nextProjectedCoord.xy / nextProjectedCoord.w) * aspectVec2;\r\n\r\n    float offsetLength = lineWidth / 2.0;\r\n    vec2 direction = normalize(nextXY - currentXY);\r\n    vec2 normalVector = vec2(-direction.y, direction.x);\r\n\tnormalVector.x = normalVector.x / aspect;\r\n    normalVector = offsetLength * normalVector;\r\n\r\n    vec4 offset = vec4(offsetSign * normalVector, 0.0, 0.0);\r\n    return offset;\r\n}\r\n\r\nvoid main() {\r\n    vec2 particleIndex = st;\r\n\t\r\n\tvec3 currentPosition = texture2D(currentParticlesPosition, particleIndex).rgb;\r\n\tvec4 nextPosition = texture2D(postProcessingPosition, particleIndex);\r\n\t\r\n\tvec4 currentProjectedCoord = vec4(0.0);\r\n\tvec4 nextProjectedCoord = vec4(0.0);\r\n\tif (nextPosition.w > 0.0) {\r\n\t\tcurrentProjectedCoord = calcProjectedCoord(currentPosition);\r\n\t\tnextProjectedCoord = calcProjectedCoord(currentPosition);\r\n\t} else {\r\n\t    currentProjectedCoord = calcProjectedCoord(currentPosition);\r\n\t\tnextProjectedCoord = calcProjectedCoord(nextPosition.xyz);\r\n\t}\r\n\r\n\tfloat pointToUse = normal.x; // -1 is currentProjectedCoord and +1 is nextProjectedCoord\r\n\tfloat offsetSign = normal.y;\r\n\t\r\n    vec4 offset = pixelSize * calcOffset(currentProjectedCoord, nextProjectedCoord, offsetSign);\r\n    if (pointToUse < 0.0) {\r\n        gl_Position = currentProjectedCoord + offset;\r\n    } else {\r\n        gl_Position = nextProjectedCoord + offset;\r\n    }\r\n\t\r\n    speedNormalization = texture2D(postProcessingSpeed, particleIndex).a;\r\n}" }, function (e, t) { e.exports = "uniform sampler2D colorTable;\r\n\r\nvarying float speedNormalization;\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(colorTable, vec2(speedNormalization, 0.0));\r\n}" }, function (e, t) { e.exports = "attribute vec3 position;\r\nattribute vec2 st;\r\n\r\nvarying vec2 textureCoordinate;\r\n\r\nvoid main() {\r\n    textureCoordinate = st;\r\n\tgl_Position = vec4(position, 1.0);\r\n}" }, function (e, t) { e.exports = "uniform sampler2D segmentsColorTexture;\r\nuniform sampler2D segmentsDepthTexture;\r\n\r\nuniform sampler2D currentTrailsColor;\r\nuniform sampler2D trailsDepthTexture;\r\n\r\nuniform float fadeOpacity;\r\n\r\nvarying vec2 textureCoordinate;\r\n\r\nvoid main() {\r\n    vec4 pointsColor = texture2D(segmentsColorTexture, textureCoordinate);\r\n    vec4 trailsColor = texture2D(currentTrailsColor, textureCoordinate);\r\n\r\n    trailsColor = floor(fadeOpacity * 255.0 * trailsColor) / 255.0; // make sure the trailsColor will be strictly decreased\r\n\r\n    float pointsDepth = texture2D(segmentsDepthTexture, textureCoordinate).r;\r\n    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\r\n\tfloat globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\r\n\t\r\n\tgl_FragColor = vec4(0.0);\r\n\tif (pointsDepth < globeDepth) {\r\n\t\tgl_FragColor = gl_FragColor + pointsColor;\r\n\t}\r\n\tif (trailsDepth < globeDepth) {\r\n\t\tgl_FragColor = gl_FragColor + trailsColor;\r\n\t}\r\n\tgl_FragDepthEXT = min(pointsDepth, trailsDepth);\r\n}" }, function (e, t) { e.exports = "uniform sampler2D trailsColorTexture;\r\nuniform sampler2D trailsDepthTexture;\r\n\r\nvarying vec2 textureCoordinate;\r\n\r\nvoid main() {\r\n    vec4 trailsColor = texture2D(trailsColorTexture, textureCoordinate);\r\n    float trailsDepth = texture2D(trailsDepthTexture, textureCoordinate).r;\r\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, textureCoordinate));\r\n\t\r\n    if (trailsDepth < globeDepth) {\r\n        gl_FragColor = trailsColor;\r\n    } else {\r\n        gl_FragColor = vec4(0.0);\r\n    }\r\n}" }, function (e, t, r) { "use strict"; function n(e) { return e && e.__esModule ? e : { default: e } } function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }), t.ParticlesComputing = void 0; var a = function () { function e(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, r, n) { return r && e(t.prototype, r), n && e(t, n), t } }(), o = r(0), s = n(o), u = r(2), l = r(1), c = r(13), d = n(c), f = r(14), p = n(f), m = r(15), v = n(m), x = r(16), h = n(x), g = r(17), P = n(g); t.ParticlesComputing = function () { function e(t, r, n, a) { i(this, e), this.data = r, this.createWindTextures(t, r), this.createParticlesTextures(t, n, a), this.createComputingPrimitives(r, n, a) } return a(e, [{ key: "createWindTextures", value: function (e, t) { var r = { context: e, width: t.dimensions.lon, height: t.dimensions.lat * t.dimensions.lev, pixelFormat: s.default.PixelFormat.LUMINANCE, pixelDatatype: s.default.PixelDatatype.FLOAT, flipY: !1, sampler: new s.default.Sampler({ minificationFilter: s.default.TextureMinificationFilter.NEAREST, magnificationFilter: s.default.TextureMagnificationFilter.NEAREST }) }; this.windTextures = { U: l.Util.createTexture(r, t.U.array), V: l.Util.createTexture(r, t.V.array) } } }, { key: "createParticlesTextures", value: function (e, t, r) { var n = { context: e, width: t.particlesTextureSize, height: t.particlesTextureSize, pixelFormat: s.default.PixelFormat.RGBA, pixelDatatype: s.default.PixelDatatype.FLOAT, flipY: !1, sampler: new s.default.Sampler({ minificationFilter: s.default.TextureMinificationFilter.NEAREST, magnificationFilter: s.default.TextureMagnificationFilter.NEAREST }) }, i = this.randomizeParticles(t.maxParticles, r); this.particlesTextures = { particlesWind: l.Util.createTexture(n), currentParticlesPosition: l.Util.createTexture(n, i), nextParticlesPosition: l.Util.createTexture(n, i), currentParticlesSpeed: l.Util.createTexture(n), nextParticlesSpeed: l.Util.createTexture(n), postProcessingPosition: l.Util.createTexture(n, i), postProcessingSpeed: l.Util.createTexture(n) } } }, { key: "randomizeParticles", value: function (e, t) { for (var r = new Float32Array(4 * e), n = 0; n < e; n++)r[4 * n] = s.default.Math.randomBetween(t.lonRange.x, t.lonRange.y), r[4 * n + 1] = s.default.Math.randomBetween(t.latRange.x, t.latRange.y), r[4 * n + 2] = s.default.Math.randomBetween(this.data.lev.min, this.data.lev.max), r[4 * n + 3] = 0; return r } }, { key: "destroyParticlesTextures", value: function () { var e = this; Object.keys(this.particlesTextures).forEach(function (t) { e.particlesTextures[t].destroy() }) } }, { key: "createComputingPrimitives", value: function (e, t, r) { var n = new s.default.Cartesian3(e.dimensions.lon, e.dimensions.lat, e.dimensions.lev), i = new s.default.Cartesian3(e.lon.min, e.lat.min, e.lev.min), a = new s.default.Cartesian3(e.lon.max, e.lat.max, e.lev.max), o = new s.default.Cartesian3((a.x - i.x) / (n.x - 1), (a.y - i.y) / (n.y - 1), n.z > 1 ? (a.z - i.z) / (n.z - 1) : 1), l = new s.default.Cartesian2(e.U.min, e.U.max), c = new s.default.Cartesian2(e.V.min, e.V.max), f = this; this.primitives = { getWind: new u.CustomPrimitive({ commandType: "Compute", uniformMap: { U: function () { return f.windTextures.U }, V: function () { return f.windTextures.V }, currentParticlesPosition: function () { return f.particlesTextures.currentParticlesPosition }, dimension: function () { return n }, minimum: function () { return i }, maximum: function () { return a }, interval: function () { return o } }, fragmentShaderSource: new s.default.ShaderSource({ sources: [d.default] }), outputTexture: this.particlesTextures.particlesWind, preExecute: function () { f.primitives.getWind.commandToExecute.outputTexture = f.particlesTextures.particlesWind } }), updateSpeed: new u.CustomPrimitive({ commandType: "Compute", uniformMap: { currentParticlesSpeed: function () { return f.particlesTextures.currentParticlesSpeed }, particlesWind: function () { return f.particlesTextures.particlesWind }, uSpeedRange: function () { return l }, vSpeedRange: function () { return c }, pixelSize: function () { return r.pixelSize }, speedFactor: function () { return t.speedFactor } }, fragmentShaderSource: new s.default.ShaderSource({ sources: [p.default] }), outputTexture: this.particlesTextures.nextParticlesSpeed, preExecute: function () { var e; e = f.particlesTextures.currentParticlesSpeed, f.particlesTextures.currentParticlesSpeed = f.particlesTextures.postProcessingSpeed, f.particlesTextures.postProcessingSpeed = e, f.primitives.updateSpeed.commandToExecute.outputTexture = f.particlesTextures.nextParticlesSpeed } }), updatePosition: new u.CustomPrimitive({ commandType: "Compute", uniformMap: { currentParticlesPosition: function () { return f.particlesTextures.currentParticlesPosition }, currentParticlesSpeed: function () { return f.particlesTextures.currentParticlesSpeed } }, fragmentShaderSource: new s.default.ShaderSource({ sources: [v.default] }), outputTexture: this.particlesTextures.nextParticlesPosition, preExecute: function () { var e; e = f.particlesTextures.currentParticlesPosition, f.particlesTextures.currentParticlesPosition = f.particlesTextures.postProcessingPosition, f.particlesTextures.postProcessingPosition = e, f.primitives.updatePosition.commandToExecute.outputTexture = f.particlesTextures.nextParticlesPosition } }), postProcessingPosition: new u.CustomPrimitive({ commandType: "Compute", uniformMap: { nextParticlesPosition: function () { return f.particlesTextures.nextParticlesPosition }, nextParticlesSpeed: function () { return f.particlesTextures.nextParticlesSpeed }, lonRange: function () { return r.lonRange }, latRange: function () { return r.latRange }, randomCoef: function () { return Math.random() }, dropRate: function () { return t.dropRate }, dropRateBump: function () { return t.dropRateBump } }, fragmentShaderSource: new s.default.ShaderSource({ sources: [h.default] }), outputTexture: this.particlesTextures.postProcessingPosition, preExecute: function () { f.primitives.postProcessingPosition.commandToExecute.outputTexture = f.particlesTextures.postProcessingPosition } }), postProcessingSpeed: new u.CustomPrimitive({ commandType: "Compute", uniformMap: { postProcessingPosition: function () { return f.particlesTextures.postProcessingPosition }, nextParticlesSpeed: function () { return f.particlesTextures.nextParticlesSpeed } }, fragmentShaderSource: new s.default.ShaderSource({ sources: [P.default] }), outputTexture: this.particlesTextures.postProcessingSpeed, preExecute: function () { f.primitives.postProcessingSpeed.commandToExecute.outputTexture = f.particlesTextures.postProcessingSpeed } }) } } }]), e }() }, function (e, t) { e.exports = "// the size of UV textures: width = lon, height = lat*lev\r\nuniform sampler2D U; // eastward wind \r\nuniform sampler2D V; // northward wind\r\n\r\nuniform sampler2D currentParticlesPosition; // (lon, lat, lev)\r\n\r\nuniform vec3 dimension; // (lon, lat, lev)\r\nuniform vec3 minimum; // minimum of each dimension\r\nuniform vec3 maximum; // maximum of each dimension\r\nuniform vec3 interval; // interval of each dimension\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvec2 mapPositionToNormalizedIndex2D(vec3 lonLatLev) {\r\n    // ensure the range of longitude and latitude\r\n    lonLatLev.x = mod(lonLatLev.x, 360.0);\r\n    lonLatLev.y = clamp(lonLatLev.y, -90.0, 90.0);\r\n\r\n    vec3 index3D = vec3(0.0);\r\n    index3D.x = (lonLatLev.x - minimum.x) / interval.x;\r\n    index3D.y = (lonLatLev.y - minimum.y) / interval.y;\r\n    index3D.z = (lonLatLev.z - minimum.z) / interval.z;\r\n\r\n    // the st texture coordinate corresponding to (col, row) index\r\n    // example\r\n    // data array is [0, 1, 2, 3, 4, 5], width = 3, height = 2\r\n    // the content of texture will be\r\n    // t 1.0\r\n    //    |  3 4 5\r\n    //    |\r\n    //    |  0 1 2\r\n    //   0.0------1.0 s\r\n\r\n    vec2 index2D = vec2(index3D.x, index3D.z * dimension.y + index3D.y);\r\n    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / (dimension.y * dimension.z));\r\n    return normalizedIndex2D;\r\n}\r\n\r\nfloat getWind(sampler2D windTexture, vec3 lonLatLev) {\r\n    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLatLev);\r\n    float result = texture2D(windTexture, normalizedIndex2D).r;\r\n    return result;\r\n}\r\n\r\nconst mat4 kernelMatrix = mat4(\r\n    0.0, -1.0, 2.0, -1.0, // first column\r\n    2.0, 0.0, -5.0, 3.0, // second column\r\n    0.0, 1.0, 4.0, -3.0, // third column\r\n    0.0, 0.0, -1.0, 1.0 // fourth column\r\n);\r\nfloat oneDimensionInterpolation(float t, float p0, float p1, float p2, float p3) {\r\n    vec4 tVec4 = vec4(1.0, t, t * t, t * t * t);\r\n    tVec4 = tVec4 / 2.0;\r\n    vec4 pVec4 = vec4(p0, p1, p2, p3);\r\n    return dot((tVec4 * kernelMatrix), pVec4);\r\n}\r\n\r\nfloat calculateB(sampler2D windTexture, float t, float lon, float lat, float lev) {\r\n    float lon0 = floor(lon) - 1.0 * interval.x;\r\n    float lon1 = floor(lon);\r\n    float lon2 = floor(lon) + 1.0 * interval.x;\r\n    float lon3 = floor(lon) + 2.0 * interval.x;\r\n\r\n    float p0 = getWind(windTexture, vec3(lon0, lat, lev));\r\n    float p1 = getWind(windTexture, vec3(lon1, lat, lev));\r\n    float p2 = getWind(windTexture, vec3(lon2, lat, lev));\r\n    float p3 = getWind(windTexture, vec3(lon3, lat, lev));\r\n\r\n    return oneDimensionInterpolation(t, p0, p1, p2, p3);\r\n}\r\n\r\nfloat interpolateOneTexture(sampler2D windTexture, vec3 lonLatLev) {\r\n    float lon = lonLatLev.x;\r\n    float lat = lonLatLev.y;\r\n    float lev = lonLatLev.z;\r\n\r\n    float lat0 = floor(lat) - 1.0 * interval.y;\r\n    float lat1 = floor(lat);\r\n    float lat2 = floor(lat) + 1.0 * interval.y;\r\n    float lat3 = floor(lat) + 2.0 * interval.y;\r\n\r\n    vec2 coef = lonLatLev.xy - floor(lonLatLev.xy);\r\n    float b0 = calculateB(windTexture, coef.x, lon, lat0, lev);\r\n    float b1 = calculateB(windTexture, coef.x, lon, lat1, lev);\r\n    float b2 = calculateB(windTexture, coef.x, lon, lat2, lev);\r\n    float b3 = calculateB(windTexture, coef.x, lon, lat3, lev);\r\n\r\n    return oneDimensionInterpolation(coef.y, b0, b1, b2, b3);\r\n}\r\n\r\nvec3 bicubic(vec3 lonLatLev) {\r\n    // https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm\r\n    float u = interpolateOneTexture(U, lonLatLev);\r\n    float v = interpolateOneTexture(V, lonLatLev);\r\n    float w = 0.0;\r\n    return vec3(u, v, w);\r\n}\r\n\r\nvoid main() {\r\n    // texture coordinate must be normalized\r\n    vec3 lonLatLev = texture2D(currentParticlesPosition, v_textureCoordinates).rgb;\r\n    vec3 windVector = bicubic(lonLatLev);\r\n\tgl_FragColor = vec4(windVector, 0.0);\r\n}" }, function (e, t) { e.exports = "uniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\r\nuniform sampler2D particlesWind;\r\n\r\n// use to calculate the relative speed\r\nuniform vec2 uSpeedRange; // (min, max);\r\nuniform vec2 vSpeedRange;\r\nuniform float pixelSize;\r\nuniform float speedFactor;\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvec4 calcRelativeSpeed(vec3 speed) {\r\n    vec3 percent = vec3(0.0);\r\n    percent.x = (speed.x - uSpeedRange.x) / (uSpeedRange.y - uSpeedRange.x);\r\n    percent.y = (speed.y - vSpeedRange.x) / (vSpeedRange.y - vSpeedRange.x);\r\n\tfloat normalization = length(percent);\r\n\r\n    float minRelativeSpeed = -speedFactor * pixelSize;\r\n    float maxRelativeSpeed = speedFactor * pixelSize;\r\n\r\n\tvec3 relativeSpeed = vec3(0.0);\r\n    relativeSpeed.x = mix(minRelativeSpeed, maxRelativeSpeed, percent.x);\r\n    relativeSpeed.y = mix(minRelativeSpeed, maxRelativeSpeed, percent.y);\r\n\t\r\n\treturn vec4(relativeSpeed, normalization);\r\n}\r\n\r\nvoid main() {\r\n    // texture coordinate must be normalized\r\n    vec3 currentSpeed = texture2D(currentParticlesSpeed, v_textureCoordinates).rgb;\r\n\tvec3 windVector = texture2D(particlesWind, v_textureCoordinates).rgb;\r\n\t\r\n\tvec4 nextSpeed = calcRelativeSpeed(windVector);\r\n\tgl_FragColor = nextSpeed;\r\n}" }, function (e, t) { e.exports = "uniform sampler2D currentParticlesPosition; // (lon, lat, lev)\r\nuniform sampler2D currentParticlesSpeed; // (u, v, w, normalization)\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvec2 lengthOfLonLat(vec3 lonLatLev) {\r\n    // unit conversion: meters -> longitude latitude degrees\r\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_system#Length_of_a_degree for detail\r\n\r\n    // Calculate the length of a degree of latitude and longitude in meters\r\n    float latitude = radians(lonLatLev.y);\r\n\r\n    float term1 = 111132.92;\r\n    float term2 = 559.82 * cos(2.0 * latitude);\r\n    float term3 = 1.175 * cos(4.0 * latitude);\r\n    float term4 = 0.0023 * cos(6.0 * latitude);\r\n    float latLength = term1 - term2 + term3 - term4;\r\n\r\n    float term5 = 111412.84 * cos(latitude);\r\n    float term6 = 93.5 * cos(3.0 * latitude);\r\n    float term7 = 0.118 * cos(5.0 * latitude);\r\n    float longLength = term5 - term6 + term7;\r\n\r\n    return vec2(longLength, latLength);\r\n}\r\n\r\nvoid updatePosition(vec3 lonLatLev, vec3 speed) {\r\n    vec2 lonlatLengthgth = lengthOfLonLat(lonLatLev);\r\n    float u = speed.x / lonlatLengthgth.x;\r\n    float v = speed.y / lonlatLengthgth.y;\r\n    float w = 0.0;\r\n    vec3 windVectorInLonLatLev = vec3(u, v, w);\r\n\r\n    vec3 nextParticle = lonLatLev + windVectorInLonLatLev;\r\n\r\n    gl_FragColor = vec4(nextParticle, 0.0);\r\n}\r\n\r\nvoid main() {\r\n    // texture coordinate must be normalized\r\n    vec3 lonLatLev = texture2D(currentParticlesPosition, v_textureCoordinates).rgb;\r\n    vec3 speed = texture2D(currentParticlesSpeed, v_textureCoordinates).rgb;\r\n\r\n    updatePosition(lonLatLev, speed);\r\n}" }, function (e, t) { e.exports = "uniform sampler2D nextParticlesPosition;\r\nuniform sampler2D nextParticlesSpeed; // (u, v, w, normalization)\r\n\r\n// range (min, max)\r\nuniform vec2 lonRange;\r\nuniform vec2 latRange;\r\n\r\nuniform float randomCoef; // use to improve the pseudo-random generator\r\nuniform float dropRate; // drop rate is a chance a particle will restart at random position to avoid degeneration\r\nuniform float dropRateBump;\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\n// pseudo-random generator\r\nconst vec3 randomConstants = vec3(12.9898, 78.233, 4375.85453);\r\nconst vec2 normalRange = vec2(0.0, 1.0);\r\nfloat rand(vec2 seed, vec2 range) {\r\n    vec2 randomSeed = randomCoef * seed;\r\n    float temp = dot(randomConstants.xy, randomSeed);\r\n    temp = fract(sin(temp) * (randomConstants.z + temp));\r\n    return temp * (range.y - range.x) + range.x;\r\n}\r\n\r\nvec3 generateRandomParticle(vec2 seed, float lev) {\r\n    // ensure the longitude is in [0, 360]\r\n    float randomLon = mod(rand(seed, lonRange), 360.0);\r\n    float randomLat = rand(-seed, latRange);\r\n\r\n    return vec3(randomLon, randomLat, lev);\r\n}\r\n\r\nbool particleOutbound(vec3 particle) {\r\n    return particle.y < -90.0 || particle.y > 90.0;\r\n}\r\n\r\nvoid main() {\r\n\tvec3 nextParticle = texture2D(nextParticlesPosition, v_textureCoordinates).rgb;\r\n    vec4 nextSpeed = texture2D(nextParticlesSpeed, v_textureCoordinates);\r\n    float particleDropRate = dropRate + dropRateBump * nextSpeed.a;\r\n\r\n    vec2 seed1 = nextParticle.xy + v_textureCoordinates;\r\n    vec2 seed2 = nextSpeed.xy + v_textureCoordinates;\r\n    vec3 randomParticle = generateRandomParticle(seed1, nextParticle.z);\r\n    float randomNumber = rand(seed2, normalRange);\r\n\t\r\n    if (randomNumber < particleDropRate || particleOutbound(nextParticle)) {\r\n\t\tgl_FragColor = vec4(randomParticle, 1.0); // 1.0 means this is a random particle\r\n    } else {\r\n\t\tgl_FragColor = vec4(nextParticle, 0.0);\r\n    }\r\n}" }, function (e, t) { e.exports = "uniform sampler2D postProcessingPosition;\r\nuniform sampler2D nextParticlesSpeed;\r\n\r\nvarying vec2 v_textureCoordinates;\r\n\r\nvoid main() {\r\n\tvec4 randomParticle = texture2D(postProcessingPosition, v_textureCoordinates);\r\n\tvec4 particleSpeed = texture2D(nextParticlesSpeed, v_textureCoordinates);\r\n\t\r\n    if (randomParticle.a > 0.0) {\r\n\t\tgl_FragColor = vec4(0.0);\r\n    } else {\r\n\t\tgl_FragColor = particleSpeed;\r\n    }\r\n}" }]) });