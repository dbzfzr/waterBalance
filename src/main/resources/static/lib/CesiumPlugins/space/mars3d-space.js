!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e(require("Cesium")) : "function" == typeof define && define.amd ? define(["Cesium"], e) : "object" == typeof exports ? exports.space = e(require("Cesium")) : t.space = e(t.Cesium) }("undefined" != typeof self ? self : this, function (t) { return function (t) { function e(r) { if (i[r]) return i[r].exports; var n = i[r] = { i: r, l: !1, exports: {} }; return t[r].call(n.exports, n, n.exports, e), n.l = !0, n.exports } var i = {}; return e.m = t, e.c = i, e.d = function (t, i, r) { e.o(t, i) || Object.defineProperty(t, i, { configurable: !1, enumerable: !0, get: r }) }, e.n = function (t) { var i = t && t.__esModule ? function () { return t.default } : function () { return t }; return e.d(i, "a", i), i }, e.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e.p = "", e(e.s = 4) }([function (e, i) { e.exports = t }, function (t, e, i) { "use strict"; function r(t) { this.length = t.length, this.topRadius = t.topRadius, this.bottomRadius = t.bottomRadius, this.slices = t.slices ? t.slices : 64, this.zReverse = t.zReverse } Object.defineProperty(e, "__esModule", { value: !0 }), e.CylinderGeometry = void 0; var n = i(0), a = function (t) { return t && t.__esModule ? t : { default: t } }(n), o = i(2), s = new a.default.Cartesian2, u = new a.default.Cartesian3, l = new a.default.Ray; r._createGeometry = function (t) { var e = t.length, i = t.topRadius, r = t.bottomRadius, n = t.slices, o = 2 * Math.PI / (n - 1), u = t.zReverse, l = [], h = [], d = [], m = [], f = [r, i], p = [0, u ? -e : e], c = 0, _ = Math.atan2(r - i, e), v = s; v.z = Math.sin(_); for (var y = Math.cos(_), g = 0; g < p.length; g++) { m[g] = []; for (var C = f[g], w = 0; w < n; w++) { m[g].push(c++); var x = o * w, A = C * Math.cos(x), b = C * Math.sin(x); l.push(A, b, p[g]), A = y * Math.cos(x), b = y * Math.sin(x), h.push(A, b, v.z), d.push(g / (p.length - 1), 0) } } for (var M = [], g = 1; g < p.length; g++)for (var w = 1; w < n; w++) { var P = m[g - 1][w - 1], E = m[g][w - 1], F = m[g][w], T = m[g - 1][w]; M.push(F), M.push(T), M.push(P), M.push(F), M.push(P), M.push(E), w == m[g].length - 1 && (P = m[g - 1][w], E = m[g][w], F = m[g][0], T = m[g - 1][0], M.push(F), M.push(T), M.push(P), M.push(F), M.push(P), M.push(E)) } M = new Int16Array(M), l = new Float32Array(l), h = new Float32Array(h), d = new Float32Array(d); var S = { position: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: l }), normal: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: h }), st: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: d }) }, R = a.default.BoundingSphere.fromVertices(l), G = new a.default.Geometry({ attributes: S, indices: M, primitiveType: a.default.PrimitiveType.TRIANGLES, boundingSphere: R }); return l = [], M = [], d = [], G }, r.createGeometry = function (t, e) { if (!e) return r._createGeometry(t); a.default.Matrix4.multiplyByPoint(e, a.default.Cartesian3.ZERO, u), u.clone(l.origin); var i = t.length, n = t.topRadius, s = (t.bottomRadius, t.slices), h = 2 * Math.PI / (s - 1), d = t.zReverse, m = [], f = [], p = [], c = [], _ = [0, d ? -i : i], v = 0, v = 0; m.push(0, 0, 0), f.push(1, 1), v++; for (var y = new a.default.Cartesian3, g = n / 15, C = 0; C < 16; C++) { for (var w = g * C, x = [], A = 0; A < s; A++) { var b = h * A, M = w * Math.cos(b), P = w * Math.sin(b); y.x = M, y.y = P, y.z = _[1]; var E = (0, o.extend2Earth)(y, e, l); E ? (x.push(v), m.push(M, P, _[1]), f.push(C / 15, 1), v++) : (E = u, x.push(-1)) } c.push(x) } for (var F, T, S = [0, c.length - 1], R = 0; R < S.length; R++)for (var C = S[R], A = 1; A < c[C].length; A++)F = c[C][A - 1], T = c[C][A], F >= 0 && T >= 0 && p.push(0, F, T); m = new Float32Array(m), p = new Int32Array(p), f = new Float32Array(f); var G = { position: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: m }), st: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: f }) }, k = a.default.BoundingSphere.fromVertices(m), V = new a.default.Geometry({ attributes: G, indices: p, primitiveType: a.default.PrimitiveType.TRIANGLES, boundingSphere: k }); return (0, o.computeVertexNormals)(V), m = [], p = [], V }, r.createOutlineGeometry = function (t) { var e = t.length, i = t.topRadius, r = t.bottomRadius, n = t.slices, o = 2 * Math.PI / (n - 1), u = t.zReverse, l = [], h = [], d = [], m = [], f = [r, i], p = [0, u ? -e : e], c = 0, _ = Math.atan2(r - i, e), v = s; v.z = Math.sin(_); for (var y = Math.cos(_), g = 0; g < p.length; g++) { m[g] = []; for (var C = f[g], w = 0; w < n; w++) { m[g].push(c++); var x = o * w, A = C * Math.cos(x), b = C * Math.sin(x); l.push(A, b, p[g]), A = y * Math.cos(x), b = y * Math.sin(x), h.push(A, b, v.z), d.push(g / (p.length - 1), 0) } } for (var M = [], g = 1; g < p.length; g++)for (var w = 1; w < n; w += 1) { var P = m[g - 1][w - 1], E = m[g][w - 1]; m[g][w], m[g - 1][w]; w % 8 == 1 && M.push(P, E) } M = new Int16Array(M), l = new Float32Array(l), h = new Float32Array(h), d = new Float32Array(d); var F = { position: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: l }), normal: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: h }), st: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: d }) }, T = a.default.BoundingSphere.fromVertices(l), S = new a.default.Geometry({ attributes: F, indices: M, primitiveType: a.default.PrimitiveType.LINES, boundingSphere: T }); return l = [], M = [], d = [], S }, r.fromAngleAndLength = function (t, e, i) { return t = a.default.Math.toRadians(t), new r({ topRadius: Math.tan(t) * e / 2, bottomRadius: 0, length: e, zReverse: i }) }, e.CylinderGeometry = r }, function (t, e, i) { "use strict"; function r(t) { var e = t.indices, i = t.attributes, r = e.length; if (i.position) { var a = i.position.values; if (void 0 === i.normal) i.normal = new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: new Float32Array(a.length) }); else for (var o = i.normal.values, s = 0; s < r; s++)o[s] = 0; for (var u, l, h, d = i.normal.values, m = new Cesium.Cartesian3, f = new Cesium.Cartesian3, p = new Cesium.Cartesian3, c = new Cesium.Cartesian3, _ = new Cesium.Cartesian3, s = 0; s < r; s += 3)u = 3 * e[s + 0], l = 3 * e[s + 1], h = 3 * e[s + 2], Cesium.Cartesian3.fromArray(a, u, m), Cesium.Cartesian3.fromArray(a, l, f), Cesium.Cartesian3.fromArray(a, h, p), Cesium.Cartesian3.subtract(p, f, c), Cesium.Cartesian3.subtract(m, f, _), Cesium.Cartesian3.cross(c, _, c), d[u] += c.x, d[u + 1] += c.y, d[u + 2] += c.z, d[l] += c.x, d[l + 1] += c.y, d[l + 2] += c.z, d[h] += c.x, d[h + 1] += c.y, d[h + 2] += c.z; n(t), i.normal.needsUpdate = !0 } return t } function n(t) { for (var e, i, r, n, a = t.attributes.normal.values, o = 0; o < a.length; o += 3)e = a[o], i = a[o + 1], r = a[o + 2], n = 1 / Math.sqrt(e * e + i * i + r * r), a[o] = e * n, a[o + 1] = i * n, a[o + 2] = r * n } function a(t, e, i, r) { r = r || Cesium.Ellipsoid.WGS84, Cesium.Matrix4.multiplyByPoint(e, t, o), Cesium.Cartesian3.subtract(o, i.origin, i.direction), Cesium.Cartesian3.normalize(i.direction, i.direction); var n = Cesium.IntersectionTests.rayEllipsoid(i, r), a = null; if (n && (a = Cesium.Ray.getPoint(i, n.start)), a) try { Cesium.Cartographic.fromCartesian(a, null, s) } catch (t) { return null } return a } Object.defineProperty(e, "__esModule", { value: !0 }), e.computeVertexNormals = r, e.extend2Earth = a; var o = new Cesium.Cartesian3, s = (new Cesium.Ray, new Cesium.Cartographic) }, function (t, e, i) { "use strict"; function r(t) { this._bottomWidth = t.bottomWidth, this._bottomHeight = t.bottomHeight, this._topWidth = t.topWidth, this._topHeight = t.topHeight, this._length = t.length, this._zReverse = t.zReverse, this._slices = t.slices ? t.slices : 8 } Object.defineProperty(e, "__esModule", { value: !0 }), e.FourPrismGeometry = void 0; var n = i(0), a = function (t) { return t && t.__esModule ? t : { default: t } }(n), o = i(2), s = new a.default.Cartesian3, u = new a.default.Ray; r._createGeometry = function (t) { for (var e = t._bottomWidth, i = t._bottomHeight, r = t._topWidth, n = t._topHeight, o = t._zReverse, s = (o ? -1 : 1) * t._length, u = new Float32Array(24), l = [], h = [], d = [0, s], m = [e, r], f = [i, n], p = 0, c = 0; c < 2; c++)u[3 * p] = -m[c] / 2, u[3 * p + 1] = -f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++, u[3 * p] = -m[c] / 2, u[3 * p + 1] = f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++, u[3 * p] = m[c] / 2, u[3 * p + 1] = f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++, u[3 * p] = m[c] / 2, u[3 * p + 1] = -f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++; l.push(0, 1, 3), l.push(1, 2, 3), l.push(0, 4, 5), l.push(0, 5, 1), l.push(1, 2, 6), l.push(1, 6, 5), l.push(2, 3, 7), l.push(7, 6, 2), l.push(0, 3, 7), l.push(7, 4, 0), l.push(4, 5, 6), l.push(6, 7, 4), l = new Int16Array(l), h = new Float32Array(h); var _ = { position: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: u }), st: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: h }) }, v = a.default.BoundingSphere.fromVertices(u), y = new a.default.Geometry({ attributes: _, indices: l, primitiveType: a.default.PrimitiveType.TRIANGLES, boundingSphere: v }); return y = a.default.GeometryPipeline.computeNormal(y), u = [], l = [], y }, r.createGeometry = function (t, e, i) { if (!e) return r._createGeometry(cylinderGeometry); if (a.default.Matrix4.multiplyByPoint(e, a.default.Cartesian3.ZERO, s), s.clone(u.origin), i) { var n = new a.default.Cartesian3(0, 0, -1e6); i.bCenter = (0, o.extend2Earth)(n, e, u) } var l = t._slices, h = (t._bottomWidth, t._bottomHeight, t._topWidth), d = t._topHeight, m = t._zReverse, f = (m ? -1 : 1) * t._length, p = [], c = [], _ = [], v = h / 2, y = d / 2, g = l, C = l, w = 0; p.push(0, 0, 0), _.push(1, 1), w++; for (var x = new a.default.Cartesian3, A = [], b = -C; b < C; b++) { for (var M = [], P = -g; P < g; P++) { var E = y * b / C, F = v * P / g; x.x = F, x.y = E, x.z = f; (0, o.extend2Earth)(x, e, u); p.push(F, E, f), _.push(1, 1), M.push(w), w++ } A.push(M) } for (var T, S, R = [0, A.length - 1], G = 0; G < R.length; G++)for (var b = R[G], P = 1; P < A[b].length; P++)T = A[b][P - 1], S = A[b][P], T >= 0 && S >= 0 && c.push(0, T, S); for (var k = [0, A[0].length - 1], V = 0; V < k.length; V++)for (var P = k[V], b = 1; b < A.length; b++)T = A[b - 1][P], S = A[b][P], T >= 0 && S >= 0 && c.push(0, T, S); p = new Float32Array(p), c = new Int32Array(c), _ = new Float32Array(_); var D = { position: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: p }), st: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: _ }) }, L = a.default.BoundingSphere.fromVertices(p), O = new a.default.Geometry({ attributes: D, indices: c, primitiveType: a.default.PrimitiveType.TRIANGLES, boundingSphere: L }); return (0, o.computeVertexNormals)(O), p = [], c = [], O }, r.createOutlineGeometry = function (t) { for (var e = t._bottomWidth, i = t._bottomHeight, r = t._topWidth, n = t._topHeight, o = t._zReverse, s = (o ? -1 : 1) * t._length, u = new Float32Array(24), l = [], h = [], d = [0, s], m = [e, r], f = [i, n], p = 0, c = 0; c < 2; c++)u[3 * p] = -m[c] / 2, u[3 * p + 1] = -f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++, u[3 * p] = -m[c] / 2, u[3 * p + 1] = f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++, u[3 * p] = m[c] / 2, u[3 * p + 1] = f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++, u[3 * p] = m[c] / 2, u[3 * p + 1] = -f[c] / 2, u[3 * p + 2] = d[c], h[2 * p] = c, h[2 * p + 1] = 0, p++; l.push(0, 1, 1, 2), l.push(2, 3, 3, 0), l.push(0, 4), l.push(1, 5), l.push(2, 6), l.push(3, 7), l.push(4, 5, 5, 6), l.push(6, 7, 7, 4), l = new Int16Array(l), h = new Float32Array(h); var _ = { position: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: u }), st: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: h }) }, v = a.default.BoundingSphere.fromVertices(u), y = new a.default.Geometry({ attributes: _, indices: l, primitiveType: a.default.PrimitiveType.LINES, boundingSphere: v }); return u = [], l = [], y }, r.createOutlineGeometry2 = function (t) { var e = (t._bottomWidth, t._bottomHeight, t._topWidth), i = t._topHeight, r = t._zReverse, n = (r ? -1 : 1) * t._length, s = [], u = [], l = [], h = e / 2, d = i / 2, m = 0; s.push(0, 0, 0), l.push(1, 1), m++; for (var f = [], p = -16; p < 16; p++) { for (var c = [], _ = -16; _ < 16; _++) { c.push(m); var v = d * p / 16, y = h * _ / 16; s.push(y, v, n), l.push(1, 1), m++ } f.push(c) } for (var g, C, w = [0, f.length - 1], x = 0; x < w.length; x++)for (var p = w[x], _ = 1; _ < f[p].length; _++)g = f[p][_ - 1], C = f[p][_], u.push(0, g, C); for (var A = [0, f[0].length - 1], b = 0; b < A.length; b++)for (var _ = A[b], p = 1; p < f.length; p++)g = f[p - 1][_], C = f[p][_], u.push(0, g, C); s = new Float32Array(s), u = new Int16Array(u), l = new Float32Array(l); var M = { position: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: s }), st: new a.default.GeometryAttribute({ componentDatatype: a.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: l }) }, P = a.default.BoundingSphere.fromVertices(s), E = new a.default.Geometry({ attributes: M, indices: u, primitiveType: a.default.PrimitiveType.TRIANGLES, boundingSphere: P }); return (0, o.computeVertexNormals)(E), a.default.GeometryPipeline.toWireframe(E), s = [], u = [], E }, r.fromAnglesLength = function (t, e, i, n) { var o = { length: i, zReverse: n, bottomHeight: i, bottomWidth: i, topHeight: i, topWidth: i }; return t = a.default.Math.toRadians(t), e = a.default.Math.toRadians(e), n ? (o.bottomHeight = 0, o.bottomWidth = 0, o.topHeight = i * Math.tan(t), o.topWidth = i * Math.tan(e)) : (o.topHeight = 0, o.topWidth = 0, o.bottomHeight = i * Math.tan(t), o.bottomWidth = i * Math.tan(e)), new r(o) }, e.FourPrismGeometry = r }, function (t, e, i) { "use strict"; var r = i(0), n = (function (t) { t && t.__esModule }(r), i(1)), a = i(3), o = i(5), s = i(8), u = i(9), l = i(10); window.mars3d || console.log("请首先引入 cesium-mars 基础库，才能使用该插件！ http://www.dehui.info"), mars3d.CylinderGeometry = n.CylinderGeometry, mars3d.FourPrismGeometry = a.FourPrismGeometry, mars3d.SatelliteCoverageSimulation = o.SatelliteCoverageSimulation, mars3d.galculateGroundPoly = s.galculateGroundPoly, mars3d.RadarPrimitive = u.RadarPrimitive, mars3d.CamberRadarPrimitive = l.CamberRadarPrimitive }, function (t, e, i) { "use strict"; function r(t) { return t && t.__esModule ? t : { default: t } } function n(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function a(t) { var e = []; for (var i in t.attributes) t.attributes.hasOwnProperty(i) && t.attributes[i] && e.push(i); return e } function o(t, e, i, r, n, a, o, s) { n = n || h.default.Ellipsoid.WGS84, a || (a = []), h.default.Matrix4.inverse(e, y), h.default.Matrix4.multiplyByPoint(e, h.default.Cartesian3.ZERO, C), C.clone(w.origin); var u = 0; r = Math.min(t.length, i + r); var l = Math.max(s.angle1, s.angle2) / 2, d = s.bCenter; if (d) var m = h.default.Cartographic.fromCartesian(d), f = Math.abs(h.default.Math.toDegrees(m.longitude)); for (var p = i; p < r; p += 3) { h.default.Cartesian3.unpack(t, p, g), h.default.Matrix4.multiplyByPoint(e, g, C), h.default.Cartesian3.subtract(C, w.origin, w.direction), h.default.Cartesian3.normalize(w.direction, w.direction); var c = h.default.IntersectionTests.rayEllipsoid(w, n), _ = null; if (s._adapt180 && f && (f < l || 180 - f < l)) s._depthTestChange || (s.viewer.scene.globe.depthTestAgainstTerrain = !0, s._depthTestChange = !0), _ = h.default.Ray.getPoint(w, 1e22), _.clone(C); else { if (s._adapt180 && s._depthTestChange && (s.viewer.scene.globe.depthTestAgainstTerrain = s._oldDepthTest, s._depthTestChange = !1), c && (_ = h.default.Ray.getPoint(w, c.start)), !_) { u++; continue } _.clone(C) } a[u] = C.clone(a[u]), o && o instanceof Float32Array && (h.default.Matrix4.multiplyByPoint(y, C, C), o[i + 3 * u] = C.x, o[i + 3 * u + 1] = C.y, o[i + 3 * u + 2] = C.z), u++ } return a } Object.defineProperty(e, "__esModule", { value: !0 }), e.SatelliteCoverageSimulation = void 0; var s, u = function () { function t(t, e) { for (var i = 0; i < e.length; i++) { var r = e[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function (e, i, r) { return i && t(e.prototype, i), r && t(e, r), e } }(), l = i(0), h = r(l), d = i(1), m = i(3), f = i(2), p = i(6), c = r(p), _ = i(7), v = r(_), y = new h.default.Matrix4, g = new h.default.Cartesian3, C = new h.default.Cartesian3, w = new h.default.Ray, x = new h.default.Cartographic, A = new h.default.Quaternion, b = { Cone: 1, FourPrism: 2 }, M = e.SatelliteCoverageSimulation = function () { function t(e, i) { n(this, t), i = i || {}, s = e.scene.globe.ellipsoid, this._geometry = null, this._areaType = h.default.defaultValue(i.areaType, b.FourPrism), this._angle1 = h.default.defaultValue(i.angle1, 10), this._angle2 = h.default.defaultValue(i.angle2, 10), this._length = h.default.defaultValue(i.length, 1e6), this._position = i.position, this.autoAngle = i.autoAngle, this._rotation = h.default.defaultValue(i.rotation, { heading: 0, pitch: 0, roll: 0 }), this._show = h.default.defaultValue(i.show, !0), this._outline = h.default.defaultValue(i.outline, !1), this._groundArea = h.default.defaultValue(i.groundArea, !1), this._groundOutLine = h.default.defaultValue(i.groundOutLine, !1), this.defaultColor = h.default.defaultValue(i.color, h.default.Color.YELLOW), this.defaultLineColor = i.lineColor, this._groundAreaColor = i.groundAreaColor, this._groundOutLineColor = i.groundOutLineColor, this._oldDepthTest = h.default.clone(e.scene.globe.depthTestAgainstTerrain), this._adapt180 = h.default.defaultValue(i.adapt180, !0), this._modelMatrix = h.default.Matrix4.clone(h.default.Matrix4.IDENTITY), this._quaternion = new h.default.Quaternion, this._translation = new h.default.Cartesian3, this._scale = new h.default.Cartesian3(1, 1, 1), this._matrix = new h.default.Matrix4, this._inverseMatrix = new h.default.Matrix4, this._positionCartographic = new h.default.Cartographic, this._positionCartesian = null, this._drawCommands = [], this._outlinePositions = [], this._imagingAreaPositions = [], this._depthTestChange = !1, this._trackedEntity = i.trackedEntity, this._trackPositions = [], this._trackGeometries = [], this._track = { geometry: null, needsUpdate: !1, lastestFrame: null }, this.viewer = e, this.viewer.scene.primitives.add(this), this.addGroundAreaEntity(this._groundArea || this._groundOutLine) } return u(t, [{ key: "addToScene", value: function () { this.viewer.scene.primitives.add(this), this.groundAreaEntity && this.viewer.entities.add(this.groundAreaEntity) } }, { key: "addGroundAreaEntity", value: function (t) { if (t && !this.groundAreaEntity) { var e = this, i = new h.default.PolygonHierarchy; this.groundAreaEntity = this.viewer.entities.add({ polygon: { show: this._groundArea, material: this._groundAreaColor || this.defaultColor, hierarchy: new h.default.CallbackProperty(function (t) { return i.positions = e._imagingAreaPositions, i }, !1) }, polyline: { show: this._groundOutLine, material: this._groundOutLineColor || this._groundAreaColor || this.defaultColor, width: 1.5, positions: new h.default.CallbackProperty(function (t) { return e._imagingAreaPositions }, !1) } }) } } }, { key: "mergeGeometries", value: function (t, e) { if (!t || !t.length) throw new Error("缺少geometries参数"); for (var i = [], r = !1, n = !1, o = t[0].primitiveType, s = 0; s < t.length; s++) { if (i[s] = a(t[s]), s > 0) { if (o != t[s].primitiveType) { n = !0; break } var u = i[s - 1]; if (!(r = u.length != i[s].length)) for (var l = 0; l < u.length; l++)if (u[l] != i[s][l]) { r = !0; break } } if (o = t[s].primitiveType, r || n) break } if (n) throw new Error("待合并的几何体中primitiveType属性不完全一致"); if (r) throw new Error("待合并的几何体中属性数量和和名称不完全一致"); for (var d = {}, m = i[0], s = 0; s < m.length; s++) { var f = m[s], p = t[0]; d[f] = {}; for (var c in p.attributes[f]) p.attributes[f].hasOwnProperty(c) && (d[f][c] = p.attributes[f][c]); for (var _ = Array.from(d[f].values), l = 1; l < t.length; l++) { p = t[l]; for (var v = 0; v < p.attributes[f].values.length; v++)_.push(p.attributes[f].values[v]) } d[f].values = new d[f].values.constructor(_) } for (var y = [], g = 0, l = 0; l < t.length; l++) { for (var p = t[0], s = 0; s < p.indices.length; s++)y.push(p.indices[s] + g); g += p.attributes.position.values.length / 3 } var C = h.default.BoundingSphere.fromVertices(d.position.values); return new h.default.Geometry({ attributes: d, indices: new Int32Array(y), primitiveType: t[0].primitiveType, boundingSphere: C }) } }, { key: "updateGeometry", value: function () { this._areaType == b.Cone ? (this._geometry = d.CylinderGeometry.createGeometry(d.CylinderGeometry.fromAngleAndLength(this._angle1, this._length, !0), this._matrix, this), this._outlineGeometry = d.CylinderGeometry.createOutlineGeometry(d.CylinderGeometry.fromAngleAndLength(this._angle1, this._length, !0))) : (this._geometry = m.FourPrismGeometry.createGeometry(m.FourPrismGeometry.fromAnglesLength(this._angle1, this._angle2, this._length, !0), this._matrix, this), this._outlineGeometry = m.FourPrismGeometry.createOutlineGeometry(m.FourPrismGeometry.fromAnglesLength(this._angle1, this._angle2, this._length, !0))), this._positions = new Float32Array(this._geometry.attributes.position.values.length); for (var t = 0; t < this._positions.length; t++)this._positions[t] = this._geometry.attributes.position.values[t]; this._outlinePositions = [] } }, { key: "updateVolumeGeometry", value: function () { var t = 1 + this._imagingAreaPositions.length, e = new Float32Array(3 + 3 * this._imagingAreaPositions.length), i = 0; e[i++] = this._positionCartesian.x, e[i++] = this._positionCartesian.y, e[i++] = this._positionCartesian.z; for (var r = 0; r < this._imagingAreaPositions.length; r++)e[i++] = this._imagingAreaPositions[r].x, e[i++] = this._imagingAreaPositions[r].y, e[i++] = this._imagingAreaPositions[r].z; for (var n = [], a = [], r = 1; r < t - 1; r++)n.push(0, r, r + 1), a.push(0, r); n = t >= 65535 ? new Uint32Array(n) : new Uint16Array(n); var o = { position: new h.default.GeometryAttribute({ componentDatatype: h.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: e }) }, s = h.default.BoundingSphere.fromVertices(e), u = new h.default.Geometry({ attributes: o, indices: n, primitiveType: h.default.PrimitiveType.TRIANGLES, boundingSphere: s }), l = new h.default.Geometry({ attributes: o, indices: new Uint32Array(a), primitiveType: h.default.PrimitiveType.LINES, boundingSphere: s }); (0, f.computeVertexNormals)(u), this._volumeGeometry = u, this._volumeOutlineGeometry = l } }, { key: "updateImagingAreaGeometry", value: function (t) { if (this._track.lastestFrame) { var e = this._track.lastestFrame.length != this._outlinePositions.length; if (!e) for (var i = 0; i < this._track.lastestFrame.length; i++)if (!this._track.lastestFrame[i].equals(this._outlinePositions[i])) { e = !0; break } if (!e) return } if (this._track.lastestFrame && this._track.lastestFrame.length == this._outlinePositions.length) for (var i = 0; i < this._outlinePositions.length; i++)this._outlinePositions[i].clone(this._track.lastestFrame[i]); else { this._track.lastestFrame = []; for (var i = 0; i < this._outlinePositions.length; i++)this._track.lastestFrame.push(this._outlinePositions[i].clone()) } var r = this.updateImagingAreaGeometry2(t); if (this._trackGeometries.push(r), this._track.geometry) { var n = this._track.geometry.attributes; for (var i in n) n.hasOwnProperty(i) && delete n[i]; for (var i in this._track.geometry) this._track.geometry.hasOwnProperty(i) && delete this._track.geometry[i] } this._track.geometry = this.mergeGeometries(this._trackGeometries), this._track.needsUpdate = !0 } }, { key: "update", value: function (t) { if (this._show && (this.computeMatrix(t.time), this._positionCartesian)) { this._geometry || this.updateGeometry(), this._outlinePositions = o(this._positions, this._matrix, 3, this._positions.length - 3, s, this._outlinePositions, this._geometry.attributes.position.values, this), this._imagingAreaPositions.splice(0, this._imagingAreaPositions.length); var e = this.exportImagingArea(); if (e && e.length) { for (var i = 0; i < e.length; i++) { var r = e[i]; this._imagingAreaPositions.push(h.default.Cartesian3.fromDegrees(r[0], r[1])) } t.mode === h.default.SceneMode.SCENE3D ? (this.updateVolumeGeometry(), this._volumeGeometry && (this._volumeCommand && (this._volumeCommand.vertexArray = this._volumeCommand.vertexArray && this._volumeCommand.vertexArray.destroy(), this._volumeCommand = null), this._volumeCommand = this.createDrawCommand(this._volumeGeometry, t, h.default.Matrix4.IDENTITY.clone()), t.commandList.push(this._volumeCommand), this._outline && (this._volumeOutlineCommand && (this._volumeOutlineCommand.vertexArray = this._volumeOutlineCommand.vertexArray && this._volumeOutlineCommand.vertexArray.destroy(), this._volumeOutlineCommand = null), this._volumeOutlineCommand = this.createDrawCommand(this._volumeOutlineGeometry, t, h.default.Matrix4.IDENTITY.clone()), t.commandList.push(this._volumeOutlineCommand))), this.groundAreaEntity && (this.groundAreaEntity.polygon.show = this._groundArea && this._show, this.groundAreaEntity.polyline.show = this._groundOutLine && this._show)) : (this.groundAreaEntity || this.addGroundAreaEntity(!0), this.groundAreaEntity.polygon.show = !0) } else this._outline && (this._outlineGeometry._drawCommand || (this._outlineGeometry._drawCommand = this.createDrawCommand(this._outlineGeometry, t)), t.commandList.push(this._outlineGeometry._drawCommand)), this.groundAreaEntity && (this.groundAreaEntity.polygon.show = !1, this.groundAreaEntity.polyline.show = !1) } } }, { key: "createDrawCommand", value: function (t, e, i) { var r = e.context, n = new h.default.Cartesian3; h.default.Matrix4.multiplyByPoint(this._matrix, t.boundingSphere.center, n); var a = (new h.default.BoundingSphere(n, t.boundingSphere.radius), new h.default.DrawCommand({ modelMatrix: i || this._matrix, owner: this, primitiveType: t.primitiveType, pass: h.default.Pass.OPAQUE })), o = this, s = h.default.GeometryPipeline.createAttributeLocations(t); return a.vertexArray = h.default.VertexArray.fromGeometry({ context: r, geometry: t, attributeLocations: s, bufferUsage: h.default.BufferUsage.STATIC_DRAW }), a.vertexArray._attributeLocations = s, a.shaderProgram = h.default.ShaderProgram.replaceCache({ context: r, vertexShaderSource: v.default, fragmentShaderSource: c.default, attributeLocations: s }), a.renderState = h.default.RenderState.fromCache({ blending: h.default.BlendingState.ALPHA_BLEND, depthTest: { enabled: !0, func: h.default.DepthFunction.LESS }, cull: { enabled: !1, face: h.default.CullFace.BACK }, depthMask: !1 }), a.uniformMap = {}, a.uniformMap.projectionMatrix = function () { return e.context.uniformState.projection }, a.uniformMap.modelViewMatrix = function () { return e.context.uniformState.modelView }, a.uniformMap.shininess = function () { return o.shininess || (o.shininess = 0), o.shininess }, a.uniformMap.emission = function () { return o.emission || (o.emission = new h.default.Cartesian3(.2, .2, .2)), o.emission }, a.uniformMap.specular = function () { return o.specular || (o.specular = 0), o.specular }, a.uniformMap.isLine = function () { return t.primitiveType == h.default.PrimitiveType.LINES }, a.uniformMap.defaultColor = function () { return t.color ? t.color : t.primitiveType == h.default.PrimitiveType.LINES ? o.defaultLineColor || o.defaultColor || new h.default.Color(1, 1, 0, .5) : o.defaultColor || new h.default.Color(1, 0, 0, 1) }, a.uniformMap.picked = function () { return o.picked || (o.picked = 0), o.picked }, a.uniformMap.pickedColor = function () { return o.pickedColor || (o.pickedColor = new h.default.Color(1, 1, 0, 1)), o.pickedColor }, a.uniformMap.normalMatrix = function () { return e.context.uniformState.normal }, a.uniformMap.glowPower = function () { return .25 }, a } }, { key: "clearCommands", value: function () { this._drawCommands.forEach(function (t) { t.vertexArray.destroy() }), this._drawCommands = [] } }, { key: "computeMatrix", value: function (t, e) { if (this.position instanceof h.default.Cartesian3 ? this._positionCartesian = this.position : "function" == typeof this.position.getValue ? this._positionCartesian = this.position.getValue(t) : this.position._value && this.position._value instanceof h.default.Cartesian3 && (this._positionCartesian = this.position._value), !this._positionCartesian) return this._matrix = new h.default.Matrix4, this._matrix; if (this._modelMatrix = h.default.Transforms.eastNorthUpToFixedFrame(this._positionCartesian, s, this._modelMatrix), this._positionCartographic = h.default.Cartographic.fromCartesian(this._positionCartesian, s, this._positionCartographic), h.default.Transforms.eastNorthUpToFixedFrame(this._positionCartesian, s, this._modelMatrix), this.autoAngle && this._trackedEntity && this._trackedEntity.orientation) { var i = h.default.Property.getValueOrUndefined(this._trackedEntity.orientation, t, A); if (this._positionCartesian && i) { var r = mars3d.matrix.getHeadingPitchRollByOrientation(this._positionCartesian, i); this._rotation.heading = r.heading } } return h.default.Quaternion.fromHeadingPitchRoll(this._rotation, this._quaternion), this._matrix = h.default.Matrix4.fromTranslationQuaternionRotationScale(this._translation, this._quaternion, this._scale, this._matrix), h.default.Matrix4.multiplyTransformation(this._modelMatrix, this._matrix, this._matrix), h.default.Matrix4.inverseTransformation(this._matrix, this._inverseMatrix), this._matrix } }, { key: "exportImagingArea", value: function (t, e) { var i = this._outlinePositions; if (e) { if (this.computeMatrix(e), !this._positionCartesian) return; i = o(this._positions, this._matrix, 3, this._positions.length - 3, s, null, this._geometry.attributes.position.values) } for (var r = [], n = 0; n < i.length; n++) { var a = i[n]; if (a) { h.default.Cartographic.fromCartesian(a, void 0, x); var u = [h.default.Math.toDegrees(x.longitude), h.default.Math.toDegrees(x.latitude)]; t && (u[0] = parseFloat(u[0].toFixed(t)), u[1] = parseFloat(u[1].toFixed(t))), r.push(turf.point(u)) } } var l = []; if (r.length > 0) { r = turf.featureCollection(r); var d = turf.convex(r); if (d) { var m = turf.getCoords(d); m && m.length > 0 && (l = m[0]) } } return l } }, { key: "updateImagingAreaGeometry2", value: function (t) { for (var e = [], i = [], r = 0, n = 0; n < this._outlinePositions.length; n += 2) { var a = this._outlinePositions[0]; e.push(a.x, a.y, a.z), i.push(r++) } return e = new Float32Array(e), i = new Int32Array(i), new h.default.Geometry({ attributes: { position: new h.default.GeometryAttribute({ componentDatatype: h.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: e }) }, primitiveType: h.default.PrimitiveType.LINES, indices: i, boundingSphere: h.default.BoundingSphere.fromVertices(e) }) } }, { key: "remove", value: function () { this.viewer.scene.primitives.remove(this), this.groundAreaEntity && this.viewer.entities.remove(this.groundAreaEntity) } }, { key: "destroy", value: function (t) { if (t) { this.viewer.scene.primitives.remove(this), this.groundAreaEntity && this.viewer.entities.remove(this.groundAreaEntity), this._drawCommands.forEach(function (t) { t.vertexArray = t.vertexArray && t.vertexArray.destroy() }), this._drawCommands = []; for (var e in this._outlineGeometry.attributes) this._outlineGeometry.attributes.hasOwnProperty(e) && delete this._outlineGeometry.attributes[e]; for (var e in this._geometry.attributes) this._geometry.attributes.hasOwnProperty(e) && delete this._geometry.attributes[e]; delete this._outlineGeometry, delete this._geometry, delete this._positionCartesian, delete this._position, this._outlinePositions = [] } } }, { key: "color", get: function () { return this.defaultColor }, set: function (t) { this.defaultColor = t } }, { key: "lineColor", get: function () { return this.defaultLineColor }, set: function (t) { this.defaultLineColor = t } }, { key: "trackedEntity", get: function () { return this._trackedEntity }, set: function (t) { t != this._trackedEntity && (this.position = t.position), this._trackedEntity = t } }, { key: "show", get: function () { return this._show }, set: function (t) { this._show = t } }, { key: "outline", get: function () { return this._outline }, set: function (t) { this._outline = t } }, { key: "angle1", get: function () { return this._angle1 }, set: function (t) { this._angle1 = t, this.clearCommands(), this._geometry = null } }, { key: "angle2", get: function () { return this._angle2 }, set: function (t) { this._angle2 = t, this.clearCommands(), this._geometry = null } }, { key: "areaType", get: function () { return this._areaType }, set: function (t) { this._areaType = t, this.clearCommands(), this._geometry = null } }, { key: "rotation", get: function () { return this._rotation }, set: function (t) { this._rotation = t, this.clearCommands(), this._geometry = null } }, { key: "heading", get: function () { return this._rotation.heading }, set: function (t) { this._rotation.heading = t, this.clearCommands(), this._geometry = null } }, { key: "pitch", get: function () { return this._rotation.pitch }, set: function (t) { this._rotation.pitch = t, this.clearCommands(), this._geometry = null } }, { key: "roll", get: function () { return this._rotation.roll }, set: function (t) { this._rotation.roll = t, this.clearCommands(), this._geometry = null } }, { key: "position", get: function () { return this._position }, set: function (t) { this._position = t, this._geometry = null, this._drawCommands = [] } }]), t }(); M.AreaType = b, M.extend2CartesianArray = o }, function (t, e) { t.exports = "//FACE_FORWARD当有光照的的时候，当视图正对它的时候反转法向量，避免墙体的背面是黑色的。\r\n#define FACE_FORWARD\r\nvarying vec3 v_position;\r\nvarying vec3 v_normal;\r\nuniform float picked;\r\nuniform vec4  pickedColor;\r\nuniform vec4  defaultColor;\r\nuniform float specular;\r\nuniform float shininess;\r\nuniform vec3  emission;\r\nvarying vec2 v_st;\r\nuniform bool isLine;\r\nuniform float glowPower;\r\nvoid main() {\r\n    vec3 positionToEyeEC = -v_position; \r\n    vec3 normalEC =normalize(v_normal);\r\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\r\n    vec4 color=defaultColor;\r\n    if(picked!=0.0){\r\n        color = pickedColor;\r\n    }\r\n    if(v_st.x<0.5){\r\n        color.a = color.a*( 0.75-v_st.x); \r\n    }\r\n    else  {\r\n        color.a =color.a*(v_st.x-0.25); \r\n    }\r\n    czm_material material;\r\n    material.specular = specular;\r\n    material.shininess = shininess;\r\n    material.normal =  normalEC;\r\n    material.emission =emission;//vec3(0.2,0.2,0.2);\r\n    material.diffuse = color.rgb ;\r\n    if(isLine){\r\n        material.alpha = 1.0; \r\n    }\r\n    else{\r\n        material.alpha = color.a; \r\n    }\r\n        //float glow = glowPower / abs(v_st.t  ) - (glowPower / 0.5); \r\n        // \r\n        //material.emission = max(vec3(glow - 1.0 + color.rgb), color.rgb); \r\n        //if(isLine)\r\n        //    material.alpha = clamp(0.0, 1.0, glow) * color.a; \r\n         \r\n    if(v_st.x==0.0){ \r\n          gl_FragColor =color ;\r\n    }else { \r\n        gl_FragColor =   czm_phong(normalize(positionToEyeEC), material) ; \r\n    } \r\n}" }, function (t, e) { t.exports = "#ifdef GL_ES\r\n    precision highp float;\r\n#endif\r\n\r\nattribute vec3 position;\r\nattribute vec2 st;\r\nattribute vec3 normal;\r\nuniform mat4 modelViewMatrix;\r\nuniform mat3 normalMatrix;\r\nuniform mat4 projectionMatrix;\r\nvarying vec3 v_position;\r\nvarying vec3 v_normal;\r\nvarying vec2 v_st;\r\n\r\nvarying vec3 v_light0Direction;\r\n\r\nvoid main(void) \r\n{\r\n    vec4 pos =  modelViewMatrix * vec4( position,1.0);\r\n    v_normal =  normalMatrix *  normal;\r\n    v_st = st;\r\n    v_position = pos.xyz;\r\n    v_light0Direction = mat3( modelViewMatrix) * vec3(1.0,1.0,1.0);\r\n    gl_Position =  projectionMatrix * pos;\r\n}" }, function (t, e, i) { "use strict"; function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function n(t, e, i, r, n, a, o) { n = n || l.default.Ellipsoid.WGS84, a || (a = []), l.default.Matrix4.inverse(e, m), l.default.Matrix4.multiplyByPoint(e, l.default.Cartesian3.ZERO, p), p.clone(c.origin); var s = 0; r = Math.min(t.length, i + r); for (var u = i; u < r; u += 3) { l.default.Cartesian3.unpack(t, u, f), l.default.Matrix4.multiplyByPoint(e, f, p), l.default.Cartesian3.subtract(p, c.origin, c.direction), l.default.Cartesian3.normalize(c.direction, c.direction); var h = l.default.IntersectionTests.rayEllipsoid(c, n), d = null; h && (d = l.default.Ray.getPoint(c, h.start)), d ? (d.clone(p), a[s] = p.clone(a[s]), o && o instanceof Float32Array && (l.default.Matrix4.multiplyByPoint(m, p, p), o[i + 3 * s] = p.x, o[i + 3 * s + 1] = p.y, o[i + 3 * s + 2] = p.z), s++) : s++ } return a } function a(t, e) { for (var i = new l.default.SampledPositionProperty(l.default.ReferenceFrame.INERTIAL), r = 0, n = t.length; r < n; r++) { var a = t[r]; i.addSample(a.time, a.position) } return i.setInterpolationOptions({ interpolationDegree: 2, interpolationAlgorithm: l.default.LagrangePolynomialApproximation }), new g({ position: i, angle1: e.angle, angle2: e.step || 10, areaType: e.areaType || y.FourPrism, rotation: { pitch: l.default.Math.toRadians(e.pitch || 0), roll: l.default.Math.toRadians(e.roll || 0) } }).exportShadingArea() } Object.defineProperty(e, "__esModule", { value: !0 }); var o = function () { function t(t, e) { for (var i = 0; i < e.length; i++) { var r = e[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function (e, i, r) { return i && t(e.prototype, i), r && t(e, r), e } }(); e.galculateGroundPoly = a; var s, u = i(0), l = function (t) { return t && t.__esModule ? t : { default: t } }(u), h = i(1), d = i(3), m = new l.default.Matrix4, f = new l.default.Cartesian3, p = new l.default.Cartesian3, c = new l.default.Ray, _ = new l.default.Cartographic, v = new l.default.Quaternion, y = { Cone: 1, FourPrism: 2 }, g = function () { function t(e) { r(this, t), e = e || {}, s = e.ellipsoid || l.default.Ellipsoid.WGS84, this._geometry = null, this._areaType = e.areaType ? e.areaType : y.FourPrism, this._angle1 = e.angle1 ? e.angle1 : 10, this._angle2 = e.angle2 ? e.angle2 : 10, this._length = e.length ? e.length : 1e6, this._position = e.position, this._orientation = e.orientation, this.autoAngle = l.default.defaultValue(e.autoAngle, !0), this.autoAngle && (this._orientation = new l.default.VelocityOrientationProperty(this._position)), this._rotation = e.rotation ? e.rotation : { heading: 0, pitch: 0, roll: 0 }, this._modelMatrix = l.default.Matrix4.clone(l.default.Matrix4.IDENTITY), this._quaternion = new l.default.Quaternion, this._translation = new l.default.Cartesian3, this._scale = new l.default.Cartesian3(1, 1, 1), this._matrix = new l.default.Matrix4, this._inverseMatrix = new l.default.Matrix4, this._positionCartographic = new l.default.Cartographic, this._positionCartesian = null, this._drawCommands = [], this._outlinePositions = [], this._imagingAreaPositions = [] } return o(t, [{ key: "exportShadingArea", value: function (t) { for (var e = this._position._property._times, i = [], r = 0, n = e.length; r < n; r++) { var a = e[r], o = this.exportImagingArea(a); i.push(o) } return i } }, { key: "exportImagingArea", value: function (t) { if (this.computeMatrix(t), this._positionCartesian) { this.updateGeometry(); for (var e = n(this._positions, this._matrix, 3, this._positions.length - 3, s, null, this._geometry.attributes.position.values), i = [], r = 0; r < e.length; r++) { var a = e[r]; l.default.Cartographic.fromCartesian(a, void 0, _); var o = [l.default.Math.toDegrees(_.longitude), l.default.Math.toDegrees(_.latitude)]; i.push(turf.point(o)) } var u = []; if (i.length > 0) { i = turf.featureCollection(i); var h = turf.convex(i); if (h) { var d = turf.getCoords(h); d && d.length > 0 && (u = d[0]) } } return u } } }, { key: "computeMatrix", value: function (t, e) { if (this._positionCartesian || (this._positionCartesian = new l.default.Cartesian3), this._position instanceof l.default.Cartesian3 ? this._positionCartesian = this._position : "function" == typeof this._position.getValue ? this._positionCartesian = this._position.getValue(t) : this._position._value && this._position._value instanceof l.default.Cartesian3 && (this._positionCartesian = this._position._value), !this._positionCartesian) return this._matrix; if (this._modelMatrix = l.default.Transforms.eastNorthUpToFixedFrame(this._positionCartesian, s, this._modelMatrix), this._positionCartographic = l.default.Cartographic.fromCartesian(this._positionCartesian, s, this._positionCartographic), l.default.Transforms.eastNorthUpToFixedFrame(this._positionCartesian, s, this._modelMatrix), this.autoAngle && this._orientation) { var i = l.default.Property.getValueOrUndefined(this._orientation, t, v); if (i) { var r = mars3d.matrix.getHeadingPitchRollByOrientation(this._positionCartesian, i); this._rotation.heading = r.heading } } return l.default.Quaternion.fromHeadingPitchRoll(this._rotation, this._quaternion), this._matrix = l.default.Matrix4.fromTranslationQuaternionRotationScale(this._translation, this._quaternion, this._scale, this._matrix), l.default.Matrix4.multiplyTransformation(this._modelMatrix, this._matrix, this._matrix), l.default.Matrix4.inverseTransformation(this._matrix, this._inverseMatrix), this._matrix } }, { key: "updateGeometry", value: function () { this._areaType == y.Cone ? (this._geometry = h.CylinderGeometry.createGeometry(h.CylinderGeometry.fromAngleAndLength(this._angle1, this._length, !0), this._matrix), this._outlineGeometry = h.CylinderGeometry.createOutlineGeometry(h.CylinderGeometry.fromAngleAndLength(this._angle1, this._length, !0))) : (this._geometry = d.FourPrismGeometry.createGeometry(d.FourPrismGeometry.fromAnglesLength(this._angle1, this._angle2, this._length, !0), this._matrix), this._outlineGeometry = d.FourPrismGeometry.createOutlineGeometry(d.FourPrismGeometry.fromAnglesLength(this._angle1, this._angle2, this._length, !0))), this._positions = new Float32Array(this._geometry.attributes.position.values.length); for (var t = 0; t < this._positions.length; t++)this._positions[t] = this._geometry.attributes.position.values[t]; this._outlinePositions = [] } }]), t }() }, function (t, e, i) { "use strict"; function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(e, "__esModule", { value: !0 }), e.RadarPrimitive = void 0; var n, a = function () { function t(t, e) { for (var i = 0; i < e.length; i++) { var r = e[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function (e, i, r) { return i && t(e.prototype, i), r && t(e, r), e } }(), o = i(0), s = function (t) { return t && t.__esModule ? t : { default: t } }(o), u = i(1), l = i(2), h = new s.default.Cartesian3; e.RadarPrimitive = function () { function t(e, i) { r(this, t), i = i || {}, n = e.scene.globe.ellipsoid, this._geometry = null, this._angle = i.angle, this._radius = i.radius ? i.radius : 5, this._position = i.position, this._rotation = i.rotation ? i.rotation : { heading: 0, pitch: 0, roll: 0 }, this._trackedEntity = i.trackedEntity, this.defaultColor = i.color ? i.color : s.default.Color.YELLOW, this.defaultLineColor = i.lineColor ? i.lineColor : this.defaultColor, this.hintPotsNum = i.hintPotsNum ? i.hintPotsNum : 15, this._show = s.default.defaultValue(i.show, !0), this._outline = s.default.defaultValue(i.outline, !1), this._topShow = s.default.defaultValue(i.top, !0), this._topOutline = s.default.defaultValue(i.topOutline, !0), this._modelMatrix = s.default.Matrix4.clone(s.default.Matrix4.IDENTITY), this._quaternion = new s.default.Quaternion, this._translation = new s.default.Cartesian3, this._scale = new s.default.Cartesian3(1, 1, 1), this._matrix = new s.default.Matrix4, this._inverseMatrix = new s.default.Matrix4, this._positionCartographic = new s.default.Cartographic, this._positionCartesian = null, this._drawCommands = [], this._outlinePositions = [], this.viewer = e, this.viewer.scene.primitives.add(this), this.updateGeometry(), this._groundArea = s.default.defaultValue(i.groundArea, !1), this.addGroundAreaEntity(this._groundArea), this.addHintLines() } return a(t, [{ key: "updateGroundCircleRadius", value: function () { this._ground_radius = this._radius * Math.cos(s.default.Math.toRadians(this._angle)) } }, { key: "addGroundAreaEntity", value: function (t) { if (t && !this.groundAreaEntity) { var e = this; this.updateGroundCircleRadius(), this.groundAreaEntity = viewer.entities.add({ position: this._position, ellipse: { show: 0 === this._rotation.pitch && 0 === this._rotation.roll, semiMinorAxis: new s.default.CallbackProperty(function (t) { return e._ground_radius }, !1), semiMajorAxis: new s.default.CallbackProperty(function (t) { return e._ground_radius }, !1), material: this.defaultColor }, polyline: { show: this._trackedEntityPosition && (0 !== this._rotation.pitch || 0 !== this._rotation.roll), positions: new s.default.CallbackProperty(function (t) { return e._trackedEntityPosition ? s.default.Cartesian3.distance(e._position, e._trackedEntityPosition) > e._radius ? [] : [e._position, e._trackedEntityPosition] : [] }, !1), followSurface: !1, material: new s.default.PolylineDashMaterialProperty({ color: s.default.Color.CYAN }), width: 1 } }) } } }, { key: "computeHintPots", value: function () { for (var t = [], e = this._radius * Math.sin(s.default.Math.toRadians(90 - this._angle)), i = s.default.Matrix4.multiplyByPoint(this._matrix, this.lbcenter, new s.default.Cartesian3), r = s.default.Cartesian3.subtract(i, this._position, new s.default.Cartesian3), n = s.default.Cartesian3.cross(r, i, new s.default.Cartesian3), a = s.default.Cartesian3.cross(i, r, new s.default.Cartesian3), o = 0; o <= this.hintPotsNum; o++) { var u = new s.default.Ray(i, n), l = e * o / this.hintPotsNum, h = s.default.Ray.getPoint(u, l, new s.default.Cartesian3), d = s.default.Cartesian3.subtract(h, this._position, new s.default.Cartesian3); u = new s.default.Ray(this._position, d); var m = s.default.Ray.getPoint(u, this._radius, new s.default.Cartesian3); t.push(m) } t.push(this._position); for (var o = this.hintPotsNum; o >= 0; o--) { var u = new s.default.Ray(i, a), l = e * o / this.hintPotsNum, h = s.default.Ray.getPoint(u, l, new s.default.Cartesian3), d = s.default.Cartesian3.subtract(h, this._position, new s.default.Cartesian3); u = new s.default.Ray(this._position, d); var m = s.default.Ray.getPoint(u, this._radius, new s.default.Cartesian3); t.push(m) } return t } }, { key: "addHintLines", value: function () { if (!this.hintLines) { var t = this; this.hintLines = viewer.entities.add({ polygon: { hierarchy: new s.default.CallbackProperty(function (e, i) { return new s.default.PolygonHierarchy(t.computeHintPots()) }, !1), outline: !0, outlineColor: s.default.Color.WHITE.withAlpha(1), outlineWidth: 1, material: s.default.Color.RED.withAlpha(.5) }, show: this.viewer.scene._mode == s.default.SceneMode.SCENE2D }) } } }, { key: "computeMatrix", value: function (t, e) { if (this.position instanceof s.default.Cartesian3 ? this._positionCartesian = this.position : "function" == typeof this.position.getValue ? this._positionCartesian = this.position.getValue(t) : this.position._value && this.position._value instanceof s.default.Cartesian3 && (this._positionCartesian = this.position._value), !this._positionCartesian) return this._matrix = new s.default.Matrix4, this._matrix; if (this._trackedEntity && this._trackedEntity.position) { var i = this._positionCartesian, r = s.default.Property.getValueOrUndefined(this._trackedEntity.position, t, h); if (r) { this._trackedEntityPosition = r; var a = mars3d.matrix.getHeadingPitchRollForLine(i, r, n); this._rotation.heading = a.heading, this._rotation.pitch = a.pitch, this._rotation.roll = a.roll } } return this._modelMatrix = s.default.Transforms.eastNorthUpToFixedFrame(this._positionCartesian, n, this._modelMatrix), this._positionCartographic = s.default.Cartographic.fromCartesian(this._positionCartesian, n, this._positionCartographic), s.default.Transforms.eastNorthUpToFixedFrame(this._positionCartesian, n, this._modelMatrix), s.default.Quaternion.fromHeadingPitchRoll(this._rotation, this._quaternion), this._matrix = s.default.Matrix4.fromTranslationQuaternionRotationScale(this._translation, this._quaternion, this._scale, this._matrix), s.default.Matrix4.multiplyTransformation(this._modelMatrix, this._matrix, this._matrix), s.default.Matrix4.inverseTransformation(this._matrix, this._inverseMatrix), this._matrix } }, { key: "getTopGeometry", value: function () { var t = this.radius, e = [], i = [], r = [], n = [], a = 90 - parseInt(this.angle), o = a < 1 ? a / 8 : 1, u = 2 * Math.PI / 127; this.lbcenter = new s.default.Cartesian3(0, 0, t); for (var h = 0, d = this.angle; d < 91; d += o) { var m = s.default.Math.toRadians(d < 90 ? d : 90); m = Math.cos(m) * t; for (var f = [], p = 0; p < 128; p++) { var c = u * p, _ = m * Math.cos(c), v = m * Math.sin(c), y = Math.sqrt(t * t - _ * _ - v * v); e.push(_, v, y), i.push(1, 1), f.push(h++) } n.push(f) } for (var d = 1; d < n.length; d++)for (var p = 1; p < n[d].length; p++) { var g = n[d - 1][p - 1], C = n[d][p - 1], w = n[d][p], x = n[d - 1][p]; r.push(g, C, w), r.push(g, w, x) } e = new Float32Array(e), r = new Int32Array(r), i = new Float32Array(i); var A = { position: new s.default.GeometryAttribute({ componentDatatype: s.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: e }), st: new s.default.GeometryAttribute({ componentDatatype: s.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: i }) }, b = s.default.BoundingSphere.fromVertices(e), M = new s.default.Geometry({ attributes: A, indices: r, primitiveType: s.default.PrimitiveType.TRIANGLES, boundingSphere: b }); return (0, l.computeVertexNormals)(M), M } }, { key: "getTopOutlineGeometry", value: function () { for (var t = this.radius, e = [], i = [], r = [], n = [], a = 90 - parseInt(this.angle), o = a < 1 ? a / 8 : 1, u = 2 * Math.PI / 127, h = 0, d = this.angle; d < 91; d += o) { var m = s.default.Math.toRadians(d < 90 ? d : 90); m = Math.cos(m) * t; for (var f = [], p = 0; p < 128; p++) { var c = u * p, _ = m * Math.cos(c), v = m * Math.sin(c), y = Math.sqrt(t * t - _ * _ - v * v); e.push(_, v, y), i.push(1, 1), f.push(h++) } n.push(f) } for (var d = 1; d < n.length; d++)for (var p = 1; p < n[d].length; p++) { var g = n[d - 1][p - 1], C = n[d][p - 1], w = n[d][p]; n[d - 1][p]; p % 8 == 1 && r.push(g, C), d % 8 == 1 && r.push(C, w) } e = new Float32Array(e), r = new Int32Array(r), i = new Float32Array(i); var x = { position: new s.default.GeometryAttribute({ componentDatatype: s.default.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: e }), st: new s.default.GeometryAttribute({ componentDatatype: s.default.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: i }) }, A = s.default.BoundingSphere.fromVertices(e), b = new s.default.Geometry({ attributes: x, indices: r, primitiveType: s.default.PrimitiveType.LINES, boundingSphere: A }); return (0, l.computeVertexNormals)(b), b } }, { key: "updateGeometry", value: function () { this._geometry = u.CylinderGeometry.createGeometry(new u.CylinderGeometry({ topRadius: this._radius * Math.cos(s.default.Math.toRadians(this.angle)), bottomRadius: 0, length: this._radius * Math.sin(s.default.Math.toRadians(this.angle)) })), this._topGeometry = this.getTopGeometry(), this._topOutlineGeometry = this.getTopOutlineGeometry(), this._outlineGeometry = u.CylinderGeometry.createOutlineGeometry(new u.CylinderGeometry({ topRadius: this._radius * Math.cos(s.default.Math.toRadians(this.angle)), bottomRadius: 0, slices: 128, length: this._radius * Math.sin(s.default.Math.toRadians(this.angle)) })), this._positions = new Float32Array(this._geometry.attributes.position.values.length); for (var t = 0; t < this._positions.length; t++)this._positions[t] = this._geometry.attributes.position.values[t]; this._drawCommands && this._drawCommands.length && (this._drawCommands.forEach(function (t) { t.vertexArray = t.vertexArray && t.vertexArray.destroy() }), this._drawCommands.splice(0, this._drawCommands.length)) } }, { key: "update", value: function (t) { if (this._show) { this.computeMatrix(t.time); t.mode === s.default.SceneMode.SCENE3D ? (this._geometry.boundingSphere = s.default.BoundingSphere.fromVertices(this._geometry.attributes.position.values), this._drawCommands = [], this._drawCommands.push(this.createDrawCommand(this._geometry, t)), this._outline && this._drawCommands.push(this.createDrawCommand(this._outlineGeometry, t)), this._topShow && (this._drawCommands.push(this.createDrawCommand(this._topGeometry, t)), this._topOutline && this._drawCommands.push(this.createDrawCommand(this._topOutlineGeometry, t))), this._drawCommands.forEach(function (e) { t.commandList.push(e) }), this.groundAreaEntity && (this.groundAreaEntity.ellipse.show = this._groundArea && 0 === this._rotation.pitch && 0 === this._rotation.roll, this.groundAreaEntity.polyline.show = !1), this.hintLines && (this.hintLines.show = !1)) : (!this.hintLines || 0 === this._rotation.pitch && 0 === this._rotation.roll || (this.hintLines.show = !0), this.groundAreaEntity || this.addGroundAreaEntity(!0), this.groundAreaEntity.ellipse.show = 0 === this._rotation.pitch && 0 === this._rotation.roll, this.groundAreaEntity.polyline.show = this._trackedEntityPosition && (0 !== this._rotation.pitch || 0 !== this._rotation.roll)) } } }, { key: "getFragmentShaderSource", value: function (t) { return "\nvarying vec3 v_position;\nvarying vec3 v_normal;\nuniform float picked;\nuniform vec4  pickedColor;\nuniform vec4  defaultColor;\nuniform float specular;\nuniform float shininess;\nuniform vec3  emission;\nvarying vec2 v_st;\nuniform bool isLine;\nuniform float glowPower;\nvoid main() {\n    vec3 positionToEyeEC = -v_position; \n    vec3 normalEC =normalize(v_normal);\n    vec4 color=defaultColor;\n    if(picked!=0.0){\n        color = pickedColor;\n    }\n    //if(v_st.x<0.5){\n    //    color.a =0.75-v_st.x; \n    //}\n    //else  {\n    //    color.a =v_st.x-0.25; \n    //}\n    czm_material material;\n    material.specular = specular;\n    material.shininess = shininess;\n    material.normal =  normalEC;\n    material.emission =emission;//vec3(0.2,0.2,0.2);\n    material.diffuse = color.rgb ;\n    if(isLine){\n        material.alpha = 1.0; \n    }\n    else{\n        material.alpha =  color.a; \n    }\n        //float glow = glowPower / abs(v_st.t  ) - (glowPower / 0.5); \n        // \n        //material.emission = max(vec3(glow - 1.0 + color.rgb), color.rgb); \n        //if(isLine)\n        //    material.alpha = clamp(0.0, 1.0, glow) * color.a; \n         \n    if(v_st.x==0.0){ \n          gl_FragColor =color ;\n    }else { \n        gl_FragColor = czm_phong(normalize(positionToEyeEC), material) ; \n    } \n}" } }, { key: "getVertexShaderSource", value: function (t) { return "\n#ifdef GL_ES\n    precision highp float;\n#endif\n\nattribute vec3 position;\nattribute vec2 st;\nattribute vec3 normal;\nuniform mat4 modelViewMatrix;\nuniform mat3 normalMatrix;\nuniform mat4 projectionMatrix;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_st;\n\nvarying vec3 v_light0Direction;\n\nvoid main(void) \n{\n    vec4 pos =  czm_modelView * vec4( position,1.0);\n    v_normal =  normalMatrix *  normal;\n    v_st = st;\n    v_position = pos.xyz;\n    v_light0Direction = mat3( modelViewMatrix) * vec3(1.0,1.0,1.0);\n    gl_Position =  projectionMatrix * pos;\n}" } }, { key: "createDrawCommand", value: function (t, e, i) { var r = e.context, n = new s.default.Cartesian3; s.default.Matrix4.multiplyByPoint(this._matrix, t.boundingSphere.center, n); var a = new s.default.BoundingSphere(n, t.boundingSphere.radius), o = new s.default.DrawCommand({ modelMatrix: i || this._matrix, owner: this, primitiveType: t.primitiveType, pass: s.default.Pass.TRANSLUCENT, boundingVolume: a }), u = this, l = s.default.GeometryPipeline.createAttributeLocations(t); return o.vertexArray = s.default.VertexArray.fromGeometry({ context: r, geometry: t, attributeLocations: l, bufferUsage: s.default.BufferUsage.STATIC_DRAW }), o.vertexArray._attributeLocations = l, o.shaderProgram = s.default.ShaderProgram.replaceCache({ context: r, vertexShaderSource: this.getVertexShaderSource(t), fragmentShaderSource: this.getFragmentShaderSource(t), attributeLocations: l }), o.renderState = s.default.RenderState.fromCache({ blending: s.default.BlendingState.ALPHA_BLEND, depthTest: { enabled: !0, func: s.default.DepthFunction.LESS }, cull: { enabled: !1, face: s.default.CullFace.BACK } }), o.uniformMap = {}, o.uniformMap.projectionMatrix = function () { return u.viewer.scene.camera.frustum.projectionMatrix }, o.uniformMap.modelViewMatrix = function () { return e.context.uniformState.modelView }, o.uniformMap.shininess = function () { return u.shininess || (u.shininess = 0), u.shininess }, o.uniformMap.emission = function () { return u.emission || (u.emission = new s.default.Cartesian3(.2, .2, .2)), u.emission }, o.uniformMap.specular = function () { return u.specular || (u.specular = 0), u.specular }, o.uniformMap.isLine = function () { return t.primitiveType == s.default.PrimitiveType.LINES || t.primitiveType == s.default.PrimitiveType.LINE_STRIP }, o.uniformMap.defaultColor = function () { return t.primitiveType == s.default.PrimitiveType.LINES || t.primitiveType == s.default.PrimitiveType.LINE_STRIP ? (u.defaultLineColor || (u.defaultLineColor = new s.default.Color(1, 1, 0, 1)), u.defaultLineColor) : (u.defaultColor || (u.defaultColor = new s.default.Color(1, 0, 0, 1)), u.defaultColor) }, o.uniformMap.picked = function () { return u.picked || (u.picked = 0), u.picked }, o.uniformMap.pickedColor = function () { return u.pickedColor || (u.pickedColor = new s.default.Color(1, 1, 0, 1)), u.pickedColor }, o.uniformMap.normalMatrix = function () { return e.context.uniformState.normal }, o.uniformMap.glowPower = function () { return .25 }, o } }, { key: "remove", value: function () { this.viewer.scene.primitives.remove(this), this.groundAreaEntity && this.viewer.entities.remove(this.groundAreaEntity) } }, { key: "addToScene", value: function () { this.viewer.scene.primitives.add(this), this.groundAreaEntity && this.viewer.entities.add(this.groundAreaEntity) } }, { key: "destroy", value: function (t) { t && (this.viewer.scene.primitives.remove(this), this.groundAreaEntity && this.viewer.entities.remove(this.groundAreaEntity), this.hintLines && this.viewer.entities.remove(this.hintLines), this._drawCommands.forEach(function (t) { t.vertexArray = t.vertexArray && t.vertexArray.destroy() }), this._drawCommands = []) } }, { key: "trackedEntity", get: function () { return this._trackedEntity }, set: function (t) { this._trackedEntity = t } }, { key: "color", get: function () { return this.defaultColor }, set: function (t) { this.defaultColor = t } }, { key: "lineColor", get: function () { return this.defaultLineColor }, set: function (t) { this.defaultLineColor = t } }, { key: "show", get: function () { return this._show }, set: function (t) { this._show = t } }, { key: "outline", get: function () { return this._outline }, set: function (t) { this._outline = t, this.updateGeometry() } }, { key: "top", get: function () { return this._topShow }, set: function (t) { this._topShow = t, this.updateGeometry() } }, { key: "topOutline", get: function () { return this._topOutline }, set: function (t) { this._topOutline = t, this.updateGeometry() } }, { key: "groundArea", get: function () { return this._groundArea }, set: function (t) { this._groundArea = t, this.addGroundAreaEntity(this._groundArea) } }, { key: "angle", get: function () { return this._angle }, set: function (t) { this._angle = t, this.updateGroundCircleRadius(), this.updateGeometry() } }, { key: "radius", get: function () { return this._radius }, set: function (t) { this._radius = t, this.updateGroundCircleRadius(), this.updateGeometry() } }, { key: "heading", get: function () { return this._rotation.heading }, set: function (t) { this._rotation.heading = t } }, { key: "pitch", get: function () { return this._rotation.pitch }, set: function (t) { this._rotation.pitch = t } }, { key: "roll", get: function () { return this._rotation.roll }, set: function (t) { this._rotation.roll = t } }, { key: "position", get: function () { return this._position }, set: function (t) { this._position = t } }]), t }() }, function (t, e, i) { "use strict"; function r(t) { return t && t.__esModule ? t : { default: t } } function n(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function a(t, e) { var i = t, r = e, n = Math.cos, a = Math.sin; return [n(-i) * n(r), a(-i) * n(r), a(r)] } function o(t, e, i, r) { return t + r / i * (e - t) } function s(t, e) { var i = e.findIndex(function (e) { return e.fov > t }); if (i > 0) { var r = e[i - 1], n = e[i], a = (t - r.fov) / (n.fov - r.fov); return r.radius * (1 - a) + n.radius * a } } function u(t, e, i, r, n, u, l) { for (var h = new Float32Array((n + 1) * (u + 1) * 3), d = 0; d < n + 1; ++d)for (var m = 0; m < u + 1; ++m) { var f = o(i, r, u, m), p = a(o(t, e, n, d), f), c = l ? s(f, l) : 1; h[3 * (m * (n + 1) + d) + 0] = p[0] * c, h[3 * (m * (n + 1) + d) + 1] = p[1] * c, h[3 * (m * (n + 1) + d) + 2] = p[2] * c } return h } function l(t, e, i, r, n, u, l) { for (var h = new Float32Array((r + 1) * (n + 1) * 3), d = 0; d < r + 1; ++d)for (var m = 0; m < n + 1; ++m) { var f = o(e, i, n, m), p = a(t, f), c = u ? s(f, u) : 1, _ = l ? s(f, l) : 1, v = o(c, _, r, d); h[3 * (m * (r + 1) + d) + 0] = p[0] * v, h[3 * (m * (r + 1) + d) + 1] = p[1] * v, h[3 * (m * (r + 1) + d) + 2] = p[2] * v } return h } function h(t, e) { for (var i = new Uint16Array(t * e * 6), r = 0; r < t; ++r)for (var n = 0; n < e; ++n) { var a = n * (t + 1) + r, o = n * (t + 1) + r + 1, s = (n + 1) * (t + 1) + r, u = (n + 1) * (t + 1) + r + 1, l = 6 * (n * t + r); i[l + 0] = a, i[l + 1] = o, i[l + 2] = u, i[l + 3] = a, i[l + 4] = u, i[l + 5] = s } return i } function d(t, e, i, r) { for (var n = t * i, a = e * r, o = new Uint16Array((t + 1) * (2 * a) + (e + 1) * (2 * n) + 8), s = 0; s < t + 1; ++s)for (var u = 0; u < a; ++u) { var l = s * i; o[2 * (s * a + u) + 0] = u * (n + 1) + l, o[2 * (s * a + u) + 1] = (u + 1) * (n + 1) + l } for (var h = (t + 1) * (2 * a), d = 0; d < e + 1; ++d)for (var m = 0; m < n; ++m) { var f = d * r; o[h + 2 * (m + d * n) + 0] = f * (n + 1) + m, o[h + 2 * (m + d * n) + 1] = f * (n + 1) + m + 1 } return o } Object.defineProperty(e, "__esModule", { value: !0 }), e.CamberRadarPrimitive = void 0; var m = function () { function t(t, e) { for (var i = 0; i < e.length; i++) { var r = e[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } return function (e, i, r) { return i && t(e.prototype, i), r && t(e, r), e } }(), f = i(0), p = r(f), c = i(11), _ = r(c), v = i(12), y = r(v), g = (e.CamberRadarPrimitive = function () { function t(e) { n(this, t), this.innerFovRadiusPairs = e.innerFovRadiusPairs, this.outerFovRadiusPairs = e.outerFovRadiusPairs, this.radius = e.radius, this.startRadius = e.startRadius, this.modelMatrix = p.default.defaultValue(e.modelMatrix, p.default.Matrix4.IDENTITY), this.startFovH = p.default.defaultValue(e.startFovH, p.default.Math.toRadians(-50)), this.endFovH = p.default.defaultValue(e.endFovH, p.default.Math.toRadians(50)), this.startFovV = p.default.defaultValue(e.startFovV, p.default.Math.toRadians(5)), this.endFovV = p.default.defaultValue(e.endFovV, p.default.Math.toRadians(85)), this.segmentH = p.default.defaultValue(e.segmentH, 20), this.segmentV = p.default.defaultValue(e.segmentV, 20), this.subSegmentH = p.default.defaultValue(e.subSegmentH, 3), this.subSegmentV = p.default.defaultValue(e.subSegmentV, 3), this.faceColor = p.default.defaultValue(e.faceColor, new p.default.Color(1, 1, 0, .5)), this.lineColor = p.default.defaultValue(e.lineColor, new p.default.Color(1, 0, 0)), this.show = p.default.defaultValue(e.show, !0), this._modelMatrix = p.default.Matrix4.clone(p.default.Matrix4.IDENTITY), this._startFovH = 0, this._endFovH = 0, this._startFovV = 0, this._endFovV = 0, this._segmentH = 1, this._segmentV = 1, this._subSegmentH = 1, this._subSegmentV = 1, this._boundingSphere = new p.default.BoundingSphere, this._initBoundingSphere = void 0, this._command = void 0 } return m(t, [{ key: "_createOuterCurveCommand", value: function (t) { var e = this._subSegmentH * this._segmentH, i = this._subSegmentV * this._segmentV, r = u(this._startFovH, this._endFovH, this._startFovV, this._endFovV, e, i, this._outerFovRadiusPairs), n = u(this._startFovH, this._endFovH, this._startFovV, this._endFovV, e, i, this._outerFovRadiusPairs), a = h(e, i), o = d(this._segmentH, this._segmentV, this._subSegmentH, this._subSegmentV); return this._createRawCommand(t, r, n, a, o) } }, { key: "_createInnerCurveCommand", value: function (t) { var e = this._subSegmentH * this._segmentH, i = this._subSegmentV * this._segmentV, r = u(this._startFovH, this._endFovH, this._startFovV, this._endFovV, e, i, this._innerFovRadiusPairs), n = u(this._startFovH, this._endFovH, this._startFovV, this._endFovV, e, i, this._innerFovRadiusPairs), a = h(e, i), o = d(this._segmentH, this._segmentV, this._subSegmentH, this._subSegmentV); return this._createRawCommand(t, r, n, a, o) } }, { key: "_createLeftCrossSectionCommand", value: function (t) { var e = this._subSegmentV * this._segmentV, i = l(this._startFovH, this._startFovV, this._endFovV, 10, e, this._innerFovRadiusPairs, this._outerFovRadiusPairs), r = l(this._startFovH, this._startFovV, this._endFovV, 10, e, this._innerFovRadiusPairs, this._outerFovRadiusPairs), n = h(10, e), a = d(10, this._segmentV, 1, this._subSegmentV); return this._createRawCommand(t, i, r, n, a) } }, { key: "_createRightCrossSectionCommand", value: function (t) { var e = this._subSegmentV * this._segmentV, i = l(this._endFovH, this._startFovV, this._endFovV, 10, e, this._innerFovRadiusPairs, this._outerFovRadiusPairs), r = l(this._endFovH, this._startFovV, this._endFovV, 10, e, this._innerFovRadiusPairs, this._outerFovRadiusPairs), n = h(10, e), a = d(10, this._segmentV, 1, this._subSegmentV); return this._createRawCommand(t, i, r, n, a) } }, { key: "_createRawCommand", value: function (t, e, i, r, n) { var a = this, o = p.default.Appearance.getDefaultRenderState(!0, !1, void 0), s = p.default.RenderState.fromCache(o), u = new p.default.ShaderSource({ sources: [y.default] }), l = new p.default.ShaderSource({ sources: [_.default] }), h = { xbsjColor: function () { return a.faceColor } }, d = { xbsjColor: function () { return a.lineColor } }, m = p.default.ShaderProgram.fromCache({ context: t, vertexShaderSource: u, fragmentShaderSource: l, attributeLocations: g }), f = p.default.Buffer.createVertexBuffer({ context: t, typedArray: e, usage: p.default.BufferUsage.STATIC_DRAW }), c = p.default.Buffer.createVertexBuffer({ context: t, typedArray: i, usage: p.default.BufferUsage.STATIC_DRAW }), v = p.default.Buffer.createIndexBuffer({ context: t, typedArray: r, usage: p.default.BufferUsage.STATIC_DRAW, indexDatatype: p.default.IndexDatatype.UNSIGNED_SHORT }), C = p.default.Buffer.createIndexBuffer({ context: t, typedArray: n, usage: p.default.BufferUsage.STATIC_DRAW, indexDatatype: p.default.IndexDatatype.UNSIGNED_SHORT }), w = new p.default.VertexArray({ context: t, attributes: [{ index: 0, vertexBuffer: f, componentsPerAttribute: 3, componentDatatype: p.default.ComponentDatatype.FLOAT }, { index: 1, vertexBuffer: c, componentsPerAttribute: 3, componentDatatype: p.default.ComponentDatatype.FLOAT }], indexBuffer: v }), x = new p.default.VertexArray({ context: t, attributes: [{ index: 0, vertexBuffer: f, componentsPerAttribute: 3, componentDatatype: p.default.ComponentDatatype.FLOAT }, { index: 1, vertexBuffer: c, componentsPerAttribute: 3, componentDatatype: p.default.ComponentDatatype.FLOAT }], indexBuffer: C }), A = p.default.BoundingSphere.fromVertices(e); return { command: new p.default.DrawCommand({ vertexArray: w, primitiveType: p.default.PrimitiveType.TRIANGLES, renderState: s, shaderProgram: m, uniformMap: h, owner: this, pass: p.default.Pass.TRANSLUCENT, modelMatrix: new p.default.Matrix4, boundingVolume: new p.default.BoundingSphere, cull: !0 }), lineCommand: new p.default.DrawCommand({ vertexArray: x, primitiveType: p.default.PrimitiveType.LINES, renderState: s, shaderProgram: m, uniformMap: d, owner: this, pass: p.default.Pass.TRANSLUCENT, modelMatrix: new p.default.Matrix4, boundingVolume: new p.default.BoundingSphere, cull: !0 }), initBoundingSphere: A } } }, { key: "update", value: function (t) { var e = this; if (this.show) { (this.innerFovRadiusPairs !== this._innerFovRadiusPairs || this.outerFovRadiusPairs !== this._outerFovRadiusPairs || this.startFovH !== this._startFovH || this.endFovH !== this._endFovH || this.startFovV !== this._startFovV || this.endFovV !== this._endFovV || this.segmentH !== this._segmentH || this.segmentV !== this._segmentV || this.subSegmentH !== this._subSegmentH || this.subSegmentV !== this._subSegmentV) && (this._innerFovRadiusPairs = this.innerFovRadiusPairs, this._outerFovRadiusPairs = this.outerFovRadiusPairs, this._startFovH = this.startFovH, this._endFovH = this.endFovH, this._startFovV = this.startFovV, this._endFovV = this.endFovV, this._segmentH = this.segmentH, this._segmentV = this.segmentV, this._subSegmentH = this.subSegmentH, this._subSegmentV = this.subSegmentV, this._modelMatrix = p.default.clone(p.default.Matrix4.IDENTITY), this._destroyCommands()), p.default.defined(this._commands) && 0 !== this._commands.length || (this._commands || (this._commands = []), this._commands.push(this._createOuterCurveCommand(t.context)), this._commands.push(this._createLeftCrossSectionCommand(t.context)), this._commands.push(this._createRightCrossSectionCommand(t.context)), this._commands.push(this._createInnerCurveCommand(t.context))), p.default.Matrix4.equals(this.modelMatrix, this._modelMatrix) || (p.default.Matrix4.clone(this.modelMatrix, this._modelMatrix), this._commands.forEach(function (t) { t.command.modelMatrix = p.default.Matrix4.IDENTITY, t.command.modelMatrix = e._modelMatrix, t.command.boundingVolume = p.default.BoundingSphere.transform(t.initBoundingSphere, e._modelMatrix, e._boundingSphere), t.lineCommand.modelMatrix = p.default.Matrix4.IDENTITY, t.lineCommand.modelMatrix = e._modelMatrix, t.lineCommand.boundingVolume = p.default.BoundingSphere.transform(t.initBoundingSphere, e._modelMatrix, e._boundingSphere) })), this._commands.forEach(function (e) { e.command && t.commandList.push(e.command), e.lineCommand && t.commandList.push(e.lineCommand) }) } } }, { key: "isDestroyed", value: function () { return !1 } }, { key: "_destroyCommands", value: function () { this._commands && this._commands.forEach(function (t) { p.default.defined(t.command) && (t.command.shaderProgram = t.command.shaderProgram && t.command.shaderProgram.destroy(), t.command.vertexArray = t.command.vertexArray && t.command.vertexArray.destroy(), t.command = void 0), p.default.defined(t.lineCommand) && (t.lineCommand.shaderProgram = t.lineCommand.shaderProgram && t.lineCommand.shaderProgram.destroy(), t.lineCommand.vertexArray = t.lineCommand.vertexArray && t.lineCommand.vertexArray.destroy(), t.lineCommand = void 0) }), this._commands && (this._commands.length = 0) } }, { key: "destroy", value: function () { return this._destroyCommands(), p.default.destroyObject(this) } }, { key: "startRadius", get: function () { return this._startRadius }, set: function (t) { this._startRadius = t, this.innerFovRadiusPairs = [{ fov: p.default.Math.toRadians(0), radius: t }, { fov: p.default.Math.toRadians(10), radius: .9 * t }, { fov: p.default.Math.toRadians(20), radius: .8 * t }, { fov: p.default.Math.toRadians(30), radius: .7 * t }, { fov: p.default.Math.toRadians(40), radius: .6 * t }, { fov: p.default.Math.toRadians(50), radius: .5 * t }, { fov: p.default.Math.toRadians(60), radius: .4 * t }, { fov: p.default.Math.toRadians(70), radius: .3 * t }, { fov: p.default.Math.toRadians(80), radius: .1 * t }, { fov: p.default.Math.toRadians(90), radius: .01 * t }] } }, { key: "radius", get: function () { return this._radius }, set: function (t) { this._radius = t, this.outerFovRadiusPairs = [{ fov: p.default.Math.toRadians(0), radius: t }, { fov: p.default.Math.toRadians(10), radius: .9 * t }, { fov: p.default.Math.toRadians(20), radius: .8 * t }, { fov: p.default.Math.toRadians(30), radius: .7 * t }, { fov: p.default.Math.toRadians(40), radius: .6 * t }, { fov: p.default.Math.toRadians(50), radius: .5 * t }, { fov: p.default.Math.toRadians(60), radius: .4 * t }, { fov: p.default.Math.toRadians(70), radius: .3 * t }, { fov: p.default.Math.toRadians(80), radius: .1 * t }, { fov: p.default.Math.toRadians(90), radius: .01 * t }] } }]), t }(), { position: 0, normal: 1 }) }, function (t, e) { t.exports = "varying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n// varying vec2 v_st;\r\n\r\n// uniform sampler2D myImage;\r\nuniform vec4 xbsjColor;\r\n\r\nvoid main()\r\n{\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    #ifdef FACE_FORWARD\r\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\r\n    #endif\r\n\r\n    czm_materialInput materialInput;\r\n    materialInput.normalEC = normalEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n    // materialInput.st = v_st;\r\n\r\n    //czm_material material = czm_getMaterial(materialInput);\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    // material.diffuse = texture2D(myImage, materialInput.st).rgb;\r\n    material.diffuse = xbsjColor.rgb;\r\n    material.alpha = xbsjColor.a;\r\n\r\n    #ifdef FLAT\r\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\r\n    #else\r\n        gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\r\n    #endif\r\n}" }, function (t, e) { t.exports = "// muyao 使用double类型的position进行计算\r\n// attribute vec3 position3DHigh;\r\n// attribute vec3 position3DLow;\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n// attribute vec2 st;\r\n// attribute float batchId;\r\n\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n// varying vec2 v_st;\r\n\r\nvoid main()\r\n{\r\n    // muyao 使用double类型的position进行计算\r\n    // vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);\r\n    // v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\r\n    // v_normalEC = czm_normal * normal;                         // normal in eye coordinates\r\n    // v_st = st;\r\n    // gl_Position = czm_modelViewProjectionRelativeToEye * p;\r\n\r\n    v_positionEC = (czm_modelView * vec4(position, 1.0)).xyz;       // position in eye coordinates\r\n    v_normalEC = czm_normal * normal;                               // normal in eye coordinates\r\n    // v_st = st;\r\n    gl_Position = czm_modelViewProjection * vec4(position, 1.0);\r\n}" }]) });