/* 2020-4-13 17:44:24 | 版权所有 杭州德慧信息技术有限公司 */
function _typeof2(t) { return (_typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } !function (t, e) { "object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" === ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? module.exports = e(require("Cesium")) : "function" == typeof define && define.amd ? define(["Cesium"], e) : "object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) ? exports.esri = e(require("Cesium")) : t.esri = e(t.Cesium) }("undefined" != typeof self ? self : this, function (n) { return o = {}, i.m = r = [function (t, e, n) { "use strict"; var i, r, o, s, In = "function" == typeof Symbol && "symbol" === _typeof2(Symbol.iterator) ? function (t) { return _typeof2(t) } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof2(t) }; s = function (t) { var e = Object.freeze; function u(t) { var e, n, i, r; for (n = 1, i = arguments.length; n < i; n++)for (e in r = arguments[n]) t[e] = r[e]; return t } Object.freeze = function (t) { return t }; var o = Object.create || function (t) { return n.prototype = t, new n }; function n() { } function p(t, e) { var n = Array.prototype.slice; if (t.bind) return t.bind.apply(t, n.call(arguments, 1)); var i = n.call(arguments, 2); return function () { return t.apply(e, i.length ? i.concat(n.call(arguments)) : arguments) } } var i = 0; function l(t) { return t._leaflet_id = t._leaflet_id || ++i, t._leaflet_id } function r(t, e, n) { var i = e[1], r = e[0], o = i - r; return t === i && n ? t : ((t - r) % o + o) % o + r } function a() { return !1 } function s(t, e) { var n = Math.pow(10, void 0 === e ? 6 : e); return Math.round(t * n) / n } function h(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function c(t) { return h(t).split(/\s+/) } function f(t, e) { for (var n in t.hasOwnProperty("options") || (t.options = t.options ? o(t.options) : {}), e) t.options[n] = e[n]; return t.options } var d = /\{ *([\w_-]+) *\}/g; var g = Array.isArray || function (t) { return "[object Array]" === Object.prototype.toString.call(t) }; function m(t) { return window["webkit" + t] || window["moz" + t] || window["ms" + t] } var _ = 0; function y(t) { var e = +new Date, n = Math.max(0, 16 - (e - _)); return _ = e + n, window.setTimeout(t, n) } var v = window.requestAnimationFrame || m("RequestAnimationFrame") || y, b = window.cancelAnimationFrame || m("CancelAnimationFrame") || m("CancelRequestAnimationFrame") || function (t) { window.clearTimeout(t) }; function w(t, e, n) { if (!n || v !== y) return v.call(window, p(t, e)); t.call(e) } function x(t) { t && b.call(window, t) } var P = (Object.freeze || Object)({ freeze: e, extend: u, create: o, bind: p, lastId: i, stamp: l, throttle: function (t, e, n) { var i, r, o, s; return s = function () { i = !1, r && (o.apply(n, r), r = !1) }, o = function () { i ? r = arguments : (t.apply(n, arguments), setTimeout(s, e), i = !0) } }, wrapNum: r, falseFn: a, formatNum: s, trim: h, splitWords: c, setOptions: f, getParamString: function (t, e, n) { var i = []; for (var r in t) i.push(encodeURIComponent(n ? r.toUpperCase() : r) + "=" + encodeURIComponent(t[r])); return (e && -1 !== e.indexOf("?") ? "&" : "?") + i.join("&") }, template: function (t, i) { return t.replace(d, function (t, e) { var n = i[e]; if (void 0 === n) throw new Error("No value provided for variable " + t); return "function" == typeof n && (n = n(i)), n }) }, isArray: g, indexOf: function (t, e) { for (var n = 0; n < t.length; n++)if (t[n] === e) return n; return -1 }, emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=", requestFn: v, cancelFn: b, requestAnimFrame: w, cancelAnimFrame: x }); function S() { } S.extend = function (t) { function e() { this.initialize && this.initialize.apply(this, arguments), this.callInitHooks() } var n = e.__super__ = this.prototype, i = o(n); for (var r in (i.constructor = e).prototype = i, this) this.hasOwnProperty(r) && "prototype" !== r && "__super__" !== r && (e[r] = this[r]); return t.statics && (u(e, t.statics), delete t.statics), t.includes && (function (t) { if ("undefined" == typeof L || !L || !L.Mixin) return; t = g(t) ? t : [t]; for (var e = 0; e < t.length; e++)t[e] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack) }(t.includes), u.apply(null, [i].concat(t.includes)), delete t.includes), i.options && (t.options = u(o(i.options), t.options)), u(i, t), i._initHooks = [], i.callInitHooks = function () { if (!this._initHooksCalled) { n.callInitHooks && n.callInitHooks.call(this), this._initHooksCalled = !0; for (var t = 0, e = i._initHooks.length; t < e; t++)i._initHooks[t].call(this) } }, e }, S.include = function (t) { return u(this.prototype, t), this }, S.mergeOptions = function (t) { return u(this.prototype.options, t), this }, S.addInitHook = function (t) { var e = Array.prototype.slice.call(arguments, 1), n = "function" == typeof t ? t : function () { this[t].apply(this, e) }; return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(n), this }; var M = { on: function (t, e, n) { if ("object" === (void 0 === t ? "undefined" : In(t))) for (var i in t) this._on(i, t[i], e); else for (var r = 0, o = (t = c(t)).length; r < o; r++)this._on(t[r], e, n); return this }, off: function (t, e, n) { if (t) if ("object" === (void 0 === t ? "undefined" : In(t))) for (var i in t) this._off(i, t[i], e); else for (var r = 0, o = (t = c(t)).length; r < o; r++)this._off(t[r], e, n); else delete this._events; return this }, _on: function (t, e, n) { this._events = this._events || {}; var i = this._events[t]; i || (i = [], this._events[t] = i), n === this && (n = void 0); for (var r = { fn: e, ctx: n }, o = i, s = 0, a = o.length; s < a; s++)if (o[s].fn === e && o[s].ctx === n) return; o.push(r) }, _off: function (t, e, n) { var i, r, o; if (this._events && (i = this._events[t])) if (e) { if (n === this && (n = void 0), i) for (r = 0, o = i.length; r < o; r++) { var s = i[r]; if (s.ctx === n && s.fn === e) return s.fn = a, this._firingCount && (this._events[t] = i = i.slice()), void i.splice(r, 1) } } else { for (r = 0, o = i.length; r < o; r++)i[r].fn = a; delete this._events[t] } }, fire: function (t, e, n) { if (!this.listens(t, n)) return this; var i = u({}, e, { type: t, target: this, sourceTarget: e && e.sourceTarget || this }); if (this._events) { var r = this._events[t]; if (r) { this._firingCount = this._firingCount + 1 || 1; for (var o = 0, s = r.length; o < s; o++) { var a = r[o]; a.fn.call(a.ctx || this, i) } this._firingCount-- } } return n && this._propagateEvent(i), this }, listens: function (t, e) { var n = this._events && this._events[t]; if (n && n.length) return !0; if (e) for (var i in this._eventParents) if (this._eventParents[i].listens(t, e)) return !0; return !1 }, once: function (t, e, n) { if ("object" === (void 0 === t ? "undefined" : In(t))) { for (var i in t) this.once(i, t[i], e); return this } var r = p(function () { this.off(t, e, n).off(t, r, n) }, this); return this.on(t, e, n).on(t, r, n) }, addEventParent: function (t) { return this._eventParents = this._eventParents || {}, this._eventParents[l(t)] = t, this }, removeEventParent: function (t) { return this._eventParents && delete this._eventParents[l(t)], this }, _propagateEvent: function (t) { for (var e in this._eventParents) this._eventParents[e].fire(t.type, u({ layer: t.target, propagatedFrom: t.target }, t), !0) } }; M.addEventListener = M.on, M.removeEventListener = M.clearAllEventListeners = M.off, M.addOneTimeEventListener = M.once, M.fireEvent = M.fire, M.hasEventListeners = M.listens; var E = S.extend(M); function O(t, e, n) { this.x = n ? Math.round(t) : t, this.y = n ? Math.round(e) : e } var T = Math.trunc || function (t) { return 0 < t ? Math.floor(t) : Math.ceil(t) }; function I(t, e, n) { return t instanceof O ? t : g(t) ? new O(t[0], t[1]) : null == t ? t : "object" === (void 0 === t ? "undefined" : In(t)) && "x" in t && "y" in t ? new O(t.x, t.y) : new O(t, e, n) } function k(t, e) { if (t) for (var n = e ? [t, e] : t, i = 0, r = n.length; i < r; i++)this.extend(n[i]) } function C(t, e) { return !t || t instanceof k ? t : new k(t, e) } function A(t, e) { if (t) for (var n = e ? [t, e] : t, i = 0, r = n.length; i < r; i++)this.extend(n[i]) } function j(t, e) { return t instanceof A ? t : new A(t, e) } function R(t, e, n) { if (isNaN(t) || isNaN(e)) throw new Error("Invalid LatLng object: (" + t + ", " + e + ")"); this.lat = +t, this.lng = +e, void 0 !== n && (this.alt = +n) } function N(t, e, n) { return t instanceof R ? t : g(t) && "object" !== In(t[0]) ? 3 === t.length ? new R(t[0], t[1], t[2]) : 2 === t.length ? new R(t[0], t[1]) : null : null == t ? t : "object" === (void 0 === t ? "undefined" : In(t)) && "lat" in t ? new R(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : void 0 === e ? null : new R(t, e, n) } O.prototype = { clone: function () { return new O(this.x, this.y) }, add: function (t) { return this.clone()._add(I(t)) }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, subtract: function (t) { return this.clone()._subtract(I(t)) }, _subtract: function (t) { return this.x -= t.x, this.y -= t.y, this }, divideBy: function (t) { return this.clone()._divideBy(t) }, _divideBy: function (t) { return this.x /= t, this.y /= t, this }, multiplyBy: function (t) { return this.clone()._multiplyBy(t) }, _multiplyBy: function (t) { return this.x *= t, this.y *= t, this }, scaleBy: function (t) { return new O(this.x * t.x, this.y * t.y) }, unscaleBy: function (t) { return new O(this.x / t.x, this.y / t.y) }, round: function () { return this.clone()._round() }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, floor: function () { return this.clone()._floor() }, _floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.clone()._ceil() }, _ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, trunc: function () { return this.clone()._trunc() }, _trunc: function () { return this.x = T(this.x), this.y = T(this.y), this }, distanceTo: function (t) { var e = (t = I(t)).x - this.x, n = t.y - this.y; return Math.sqrt(e * e + n * n) }, equals: function (t) { return (t = I(t)).x === this.x && t.y === this.y }, contains: function (t) { return t = I(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y) }, toString: function () { return "Point(" + s(this.x) + ", " + s(this.y) + ")" } }, k.prototype = { extend: function (t) { return t = I(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this }, getCenter: function (t) { return new O((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t) }, getBottomLeft: function () { return new O(this.min.x, this.max.y) }, getTopRight: function () { return new O(this.max.x, this.min.y) }, getTopLeft: function () { return this.min }, getBottomRight: function () { return this.max }, getSize: function () { return this.max.subtract(this.min) }, contains: function (t) { var e, n; return (t = ("number" == typeof t[0] || t instanceof O ? I : C)(t)) instanceof k ? (e = t.min, n = t.max) : e = n = t, e.x >= this.min.x && n.x <= this.max.x && e.y >= this.min.y && n.y <= this.max.y }, intersects: function (t) { t = C(t); var e = this.min, n = this.max, i = t.min, r = t.max, o = r.x >= e.x && i.x <= n.x, s = r.y >= e.y && i.y <= n.y; return o && s }, overlaps: function (t) { t = C(t); var e = this.min, n = this.max, i = t.min, r = t.max, o = r.x > e.x && i.x < n.x, s = r.y > e.y && i.y < n.y; return o && s }, isValid: function () { return !(!this.min || !this.max) } }, A.prototype = { extend: function (t) { var e, n, i = this._southWest, r = this._northEast; if (t instanceof R) n = e = t; else { if (!(t instanceof A)) return t ? this.extend(N(t) || j(t)) : this; if (e = t._southWest, n = t._northEast, !e || !n) return this } return i || r ? (i.lat = Math.min(e.lat, i.lat), i.lng = Math.min(e.lng, i.lng), r.lat = Math.max(n.lat, r.lat), r.lng = Math.max(n.lng, r.lng)) : (this._southWest = new R(e.lat, e.lng), this._northEast = new R(n.lat, n.lng)), this }, pad: function (t) { var e = this._southWest, n = this._northEast, i = Math.abs(e.lat - n.lat) * t, r = Math.abs(e.lng - n.lng) * t; return new A(new R(e.lat - i, e.lng - r), new R(n.lat + i, n.lng + r)) }, getCenter: function () { return new R((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2) }, getSouthWest: function () { return this._southWest }, getNorthEast: function () { return this._northEast }, getNorthWest: function () { return new R(this.getNorth(), this.getWest()) }, getSouthEast: function () { return new R(this.getSouth(), this.getEast()) }, getWest: function () { return this._southWest.lng }, getSouth: function () { return this._southWest.lat }, getEast: function () { return this._northEast.lng }, getNorth: function () { return this._northEast.lat }, contains: function (t) { t = ("number" == typeof t[0] || t instanceof R || "lat" in t ? N : j)(t); var e, n, i = this._southWest, r = this._northEast; return t instanceof A ? (e = t.getSouthWest(), n = t.getNorthEast()) : e = n = t, e.lat >= i.lat && n.lat <= r.lat && e.lng >= i.lng && n.lng <= r.lng }, intersects: function (t) { t = j(t); var e = this._southWest, n = this._northEast, i = t.getSouthWest(), r = t.getNorthEast(), o = r.lat >= e.lat && i.lat <= n.lat, s = r.lng >= e.lng && i.lng <= n.lng; return o && s }, overlaps: function (t) { t = j(t); var e = this._southWest, n = this._northEast, i = t.getSouthWest(), r = t.getNorthEast(), o = r.lat > e.lat && i.lat < n.lat, s = r.lng > e.lng && i.lng < n.lng; return o && s }, toBBoxString: function () { return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",") }, equals: function (t, e) { return !!t && (t = j(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)) }, isValid: function () { return !(!this._southWest || !this._northEast) } }; var D, B = { latLngToPoint: function (t, e) { var n = this.projection.project(t), i = this.scale(e); return this.transformation._transform(n, i) }, pointToLatLng: function (t, e) { var n = this.scale(e), i = this.transformation.untransform(t, n); return this.projection.unproject(i) }, project: function (t) { return this.projection.project(t) }, unproject: function (t) { return this.projection.unproject(t) }, scale: function (t) { return 256 * Math.pow(2, t) }, zoom: function (t) { return Math.log(t / 256) / Math.LN2 }, getProjectedBounds: function (t) { if (this.infinite) return null; var e = this.projection.bounds, n = this.scale(t); return new k(this.transformation.transform(e.min, n), this.transformation.transform(e.max, n)) }, infinite: !(R.prototype = { equals: function (t, e) { return !!t && (t = N(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === e ? 1e-9 : e)) }, toString: function (t) { return "LatLng(" + s(this.lat, t) + ", " + s(this.lng, t) + ")" }, distanceTo: function (t) { return F.distance(this, N(t)) }, wrap: function () { return F.wrapLatLng(this) }, toBounds: function (t) { var e = 180 * t / 40075017, n = e / Math.cos(Math.PI / 180 * this.lat); return j([this.lat - e, this.lng - n], [this.lat + e, this.lng + n]) }, clone: function () { return new R(this.lat, this.lng, this.alt) } }), wrapLatLng: function (t) { var e = this.wrapLng ? r(t.lng, this.wrapLng, !0) : t.lng; return new R(this.wrapLat ? r(t.lat, this.wrapLat, !0) : t.lat, e, t.alt) }, wrapLatLngBounds: function (t) { var e = t.getCenter(), n = this.wrapLatLng(e), i = e.lat - n.lat, r = e.lng - n.lng; if (0 == i && 0 == r) return t; var o = t.getSouthWest(), s = t.getNorthEast(); return new A(new R(o.lat - i, o.lng - r), new R(s.lat - i, s.lng - r)) } }, F = u({}, B, { wrapLng: [-180, 180], R: 6371e3, distance: function (t, e) { var n = Math.PI / 180, i = t.lat * n, r = e.lat * n, o = Math.sin((e.lat - t.lat) * n / 2), s = Math.sin((e.lng - t.lng) * n / 2), a = o * o + Math.cos(i) * Math.cos(r) * s * s, u = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return this.R * u } }), q = { R: 6378137, MAX_LATITUDE: 85.0511287798, project: function (t) { var e = Math.PI / 180, n = this.MAX_LATITUDE, i = Math.max(Math.min(n, t.lat), -n), r = Math.sin(i * e); return new O(this.R * t.lng * e, this.R * Math.log((1 + r) / (1 - r)) / 2) }, unproject: function (t) { var e = 180 / Math.PI; return new R((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e, t.x * e / this.R) }, bounds: new k([-(D = 6378137 * Math.PI), -D], [D, D]) }; function G(t, e, n, i) { if (g(t)) return this._a = t[0], this._b = t[1], this._c = t[2], void (this._d = t[3]); this._a = t, this._b = e, this._c = n, this._d = i } function z(t, e, n, i) { return new G(t, e, n, i) } G.prototype = { transform: function (t, e) { return this._transform(t.clone(), e) }, _transform: function (t, e) { return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t }, untransform: function (t, e) { return e = e || 1, new O((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c) } }; var U, W = u({}, F, { code: "EPSG:3857", projection: q, transformation: z(U = .5 / (Math.PI * q.R), .5, -U, .5) }), H = u({}, W, { code: "EPSG:900913" }); var J, Z = document.documentElement.style, V = "ActiveXObject" in window, Y = V && !document.addEventListener, X = "msLaunchUri" in navigator && !("documentMode" in document), Q = St("webkit"), $ = St("android"), K = St("android 2") || St("android 3"), tt = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), et = $ && St("Google") && tt < 537 && !("AudioNode" in window), nt = !!window.opera, it = St("chrome"), rt = St("gecko") && !Q && !nt && !V, ot = !it && St("safari"), st = St("phantom"), at = "OTransition" in Z, ut = 0 === navigator.platform.indexOf("Win"), lt = V && "transition" in Z, ht = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !K, ct = "MozPerspective" in Z, ft = !window.L_DISABLE_3D && (lt || ht || ct) && !at && !st, dt = "undefined" != typeof orientation || St("mobile"), pt = dt && Q, gt = dt && ht, mt = !window.PointerEvent && window.MSPointerEvent, _t = !(!window.PointerEvent && !mt), yt = !window.L_NO_TOUCH && (_t || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch), vt = dt && nt, bt = dt && rt, wt = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI), xt = !!document.createElement("canvas").getContext, Lt = !(!document.createElementNS || (J = "svg", !document.createElementNS("http://www.w3.org/2000/svg", J).createSVGRect)), Pt = !Lt && function () { try { var t = document.createElement("div"); t.innerHTML = '<v:shape adj="1"/>'; var e = t.firstChild; return e.style.behavior = "url(#default#VML)", e && "object" === In(e.adj) } catch (t) { return !1 } }(); function St(t) { return 0 <= navigator.userAgent.toLowerCase().indexOf(t) } var Mt = (Object.freeze || Object)({ ie: V, ielt9: Y, edge: X, webkit: Q, android: $, android23: K, androidStock: et, opera: nt, chrome: it, gecko: rt, safari: ot, phantom: st, opera12: at, win: ut, ie3d: lt, webkit3d: ht, gecko3d: ct, any3d: ft, mobile: dt, mobileWebkit: pt, mobileWebkit3d: gt, msPointer: mt, pointer: _t, touch: yt, mobileOpera: vt, mobileGecko: bt, retina: wt, canvas: xt, svg: Lt, vml: Pt }), Et = mt ? "MSPointerDown" : "pointerdown", Ot = mt ? "MSPointerMove" : "pointermove", Tt = mt ? "MSPointerUp" : "pointerup", It = mt ? "MSPointerCancel" : "pointercancel", kt = ["INPUT", "SELECT", "OPTION"], Ct = {}, At = !1, jt = 0; function Rt(t, e, n, i) { function r(t) { Ft(t, s) } var o, s, a, u, l, h, c, f; function d(t) { (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) && Ft(t, u) } return "touchstart" === e ? (l = t, h = n, c = i, f = p(function (t) { if ("mouse" !== t.pointerType && t.MSPOINTER_TYPE_MOUSE && t.pointerType !== t.MSPOINTER_TYPE_MOUSE) { if (!(kt.indexOf(t.target.tagName) < 0)) return; Me(t) } Ft(t, h) }), l["_leaflet_touchstart" + c] = f, l.addEventListener(Et, f, !1), At || (document.documentElement.addEventListener(Et, Nt, !0), document.documentElement.addEventListener(Ot, Dt, !0), document.documentElement.addEventListener(Tt, Bt, !0), document.documentElement.addEventListener(It, Bt, !0), At = !0)) : "touchmove" === e ? (u = n, (a = t)["_leaflet_touchmove" + i] = d, a.addEventListener(Ot, d, !1)) : "touchend" === e && (s = n, (o = t)["_leaflet_touchend" + i] = r, o.addEventListener(Tt, r, !1), o.addEventListener(It, r, !1)), this } function Nt(t) { Ct[t.pointerId] = t, jt++ } function Dt(t) { Ct[t.pointerId] && (Ct[t.pointerId] = t) } function Bt(t) { delete Ct[t.pointerId], jt-- } function Ft(t, e) { for (var n in t.touches = [], Ct) t.touches.push(Ct[n]); t.changedTouches = [t], e(t) } var qt = mt ? "MSPointerDown" : _t ? "pointerdown" : "touchstart", Gt = mt ? "MSPointerUp" : _t ? "pointerup" : "touchend", zt = "_leaflet_"; function Ut(t, r, e) { var o, s, a = !1; function n(t) { var e; if (_t) { if (!X || "mouse" === t.pointerType) return; e = jt } else e = t.touches.length; if (!(1 < e)) { var n = Date.now(), i = n - (o || n); s = t.touches ? t.touches[0] : t, a = 0 < i && i <= 250, o = n } } function i(t) { if (a && !s.cancelBubble) { if (_t) { if (!X || "mouse" === t.pointerType) return; var e, n, i = {}; for (n in s) e = s[n], i[n] = e && e.bind ? e.bind(s) : e; s = i } s.type = "dblclick", r(s), o = null } } return t[zt + qt + e] = n, t[zt + Gt + e] = i, t[zt + "dblclick" + e] = r, t.addEventListener(qt, n, !1), t.addEventListener(Gt, i, !1), t.addEventListener("dblclick", r, !1), this } function Wt(t, e) { var n = t[zt + qt + e], i = t[zt + Gt + e], r = t[zt + "dblclick" + e]; return t.removeEventListener(qt, n, !1), t.removeEventListener(Gt, i, !1), X || t.removeEventListener("dblclick", r, !1), this } var Ht, Jt, Zt, Vt, Yt, Xt = ue(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), Qt = ue(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), $t = "webkitTransition" === Qt || "OTransition" === Qt ? Qt + "End" : "transitionend"; function Kt(t, e) { var n = t.style[e] || t.currentStyle && t.currentStyle[e]; if ((!n || "auto" === n) && document.defaultView) { var i = document.defaultView.getComputedStyle(t, null); n = i ? i[e] : null } return "auto" === n ? null : n } function te(t, e, n) { var i = document.createElement(t); return i.className = e || "", n && n.appendChild(i), i } function ee(t) { var e = t.parentNode; e && e.removeChild(t) } function ne(t, e) { if (void 0 !== t.classList) return t.classList.contains(e); var n = se(t); return 0 < n.length && new RegExp("(^|\\s)" + e + "(\\s|$)").test(n) } function ie(t, e) { if (void 0 !== t.classList) for (var n = c(e), i = 0, r = n.length; i < r; i++)t.classList.add(n[i]); else if (!ne(t, e)) { var o = se(t); oe(t, (o ? o + " " : "") + e) } } function re(t, e) { void 0 !== t.classList ? t.classList.remove(e) : oe(t, h((" " + se(t) + " ").replace(" " + e + " ", " "))) } function oe(t, e) { void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e } function se(t) { return void 0 === t.className.baseVal ? t.className : t.className.baseVal } function ae(t, e) { "opacity" in t.style ? t.style.opacity = e : "filter" in t.style && function (t, e) { var n = !1, i = "DXImageTransform.Microsoft.Alpha"; try { n = t.filters.item(i) } catch (t) { if (1 === e) return } e = Math.round(100 * e), n ? (n.Enabled = 100 !== e, n.Opacity = e) : t.style.filter += " progid:" + i + "(opacity=" + e + ")" }(t, e) } function ue(t) { for (var e = document.documentElement.style, n = 0; n < t.length; n++)if (t[n] in e) return t[n]; return !1 } function le(t, e, n) { var i = e || new O(0, 0); t.style[Xt] = (lt ? "translate(" + i.x + "px," + i.y + "px)" : "translate3d(" + i.x + "px," + i.y + "px,0)") + (n ? " scale(" + n + ")" : "") } function he(t, e) { t._leaflet_pos = e, ft ? le(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px") } function ce(t) { return t._leaflet_pos || new O(0, 0) } if ("onselectstart" in document) Ht = function () { be(window, "selectstart", Me) }, Jt = function () { xe(window, "selectstart", Me) }; else { var fe = ue(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]); Ht = function () { if (fe) { var t = document.documentElement.style; Zt = t[fe], t[fe] = "none" } }, Jt = function () { fe && (document.documentElement.style[fe] = Zt, Zt = void 0) } } function de() { be(window, "dragstart", Me) } function pe() { xe(window, "dragstart", Me) } function ge(t) { for (; -1 === t.tabIndex;)t = t.parentNode; t.style && (me(), Yt = (Vt = t).style.outline, t.style.outline = "none", be(window, "keydown", me)) } function me() { Vt && (Vt.style.outline = Yt, Yt = Vt = void 0, xe(window, "keydown", me)) } function _e(t) { for (; !((t = t.parentNode).offsetWidth && t.offsetHeight || t === document.body);); return t } function ye(t) { var e = t.getBoundingClientRect(); return { x: e.width / t.offsetWidth || 1, y: e.height / t.offsetHeight || 1, boundingClientRect: e } } var ve = (Object.freeze || Object)({ TRANSFORM: Xt, TRANSITION: Qt, TRANSITION_END: $t, get: function (t) { return "string" == typeof t ? document.getElementById(t) : t }, getStyle: Kt, create: te, remove: ee, empty: function (t) { for (; t.firstChild;)t.removeChild(t.firstChild) }, toFront: function (t) { var e = t.parentNode; e.lastChild !== t && e.appendChild(t) }, toBack: function (t) { var e = t.parentNode; e.firstChild !== t && e.insertBefore(t, e.firstChild) }, hasClass: ne, addClass: ie, removeClass: re, setClass: oe, getClass: se, setOpacity: ae, testProp: ue, setTransform: le, setPosition: he, getPosition: ce, disableTextSelection: Ht, enableTextSelection: Jt, disableImageDrag: de, enableImageDrag: pe, preventOutline: ge, restoreOutline: me, getSizedParentNode: _e, getScale: ye }); function be(t, e, n, i) { if ("object" === (void 0 === e ? "undefined" : In(e))) for (var r in e) Le(t, r, e[r], n); else for (var o = 0, s = (e = c(e)).length; o < s; o++)Le(t, e[o], n, i); return this } var we = "_leaflet_events"; function xe(t, e, n, i) { if ("object" === (void 0 === e ? "undefined" : In(e))) for (var r in e) Pe(t, r, e[r], n); else if (e) for (var o = 0, s = (e = c(e)).length; o < s; o++)Pe(t, e[o], n, i); else { for (var a in t[we]) Pe(t, a, t[we][a]); delete t[we] } return this } function Le(e, t, n, i) { var r = t + l(n) + (i ? "_" + l(i) : ""); if (e[we] && e[we][r]) return this; var o = function (t) { return n.call(i || e, t || window.event) }, s = o; _t && 0 === t.indexOf("touch") ? Rt(e, t, o, r) : !yt || "dblclick" !== t || _t && it ? "addEventListener" in e ? "mousewheel" === t ? e.addEventListener("onwheel" in e ? "wheel" : "mousewheel", o, !1) : "mouseenter" === t || "mouseleave" === t ? (o = function (t) { t = t || window.event, Ae(e, t) && s(t) }, e.addEventListener("mouseenter" === t ? "mouseover" : "mouseout", o, !1)) : ("click" === t && $ && (o = function (t) { !function (t, e) { var n = t.timeStamp || t.originalEvent && t.originalEvent.timeStamp, i = Te && n - Te; if (i && 100 < i && i < 500 || t.target._simulatedClick && !t._simulated) return Ee(t); Te = n, e(t) }(t, s) }), e.addEventListener(t, o, !1)) : "attachEvent" in e && e.attachEvent("on" + t, o) : Ut(e, o, r), e[we] = e[we] || {}, e[we][r] = o } function Pe(t, e, n, i) { var r, o, s, a = e + l(n) + (i ? "_" + l(i) : ""), u = t[we] && t[we][a]; if (!u) return this; _t && 0 === e.indexOf("touch") ? (s = (r = t)["_leaflet_" + (o = e) + a], "touchstart" === o ? r.removeEventListener(Et, s, !1) : "touchmove" === o ? r.removeEventListener(Ot, s, !1) : "touchend" === o && (r.removeEventListener(Tt, s, !1), r.removeEventListener(It, s, !1))) : !yt || "dblclick" !== e || _t && it ? "removeEventListener" in t ? "mousewheel" === e ? t.removeEventListener("onwheel" in t ? "wheel" : "mousewheel", u, !1) : t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, u, !1) : "detachEvent" in t && t.detachEvent("on" + e, u) : Wt(t, a), t[we][a] = null } function Se(t) { return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, Ce(t), this } function Me(t) { return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this } function Ee(t) { return Me(t), Se(t), this } var Oe = ut && it ? 2 * window.devicePixelRatio : rt ? window.devicePixelRatio : 1; var Te, Ie = {}; function ke(t) { Ie[t.type] = !0 } function Ce(t) { var e = Ie[t.type]; return Ie[t.type] = !1, e } function Ae(t, e) { var n = e.relatedTarget; if (!n) return !0; try { for (; n && n !== t;)n = n.parentNode } catch (t) { return !1 } return n !== t } var je = (Object.freeze || Object)({ on: be, off: xe, stopPropagation: Se, disableScrollPropagation: function (t) { return Le(t, "mousewheel", Se), this }, disableClickPropagation: function (t) { return be(t, "mousedown touchstart dblclick", Se), Le(t, "click", ke), this }, preventDefault: Me, stop: Ee, getMousePosition: function (t, e) { if (!e) return new O(t.clientX, t.clientY); var n = ye(e), i = n.boundingClientRect; return new O((t.clientX - i.left) / n.x - e.clientLeft, (t.clientY - i.top) / n.y - e.clientTop) }, getWheelDelta: function (t) { return X ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / Oe : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0 }, fakeStop: ke, skipped: Ce, isExternalTarget: Ae, addListener: be, removeListener: xe }), Re = E.extend({ run: function (t, e, n, i) { this.stop(), this._el = t, this._inProgress = !0, this._duration = n || .25, this._easeOutPower = 1 / Math.max(i || .5, .2), this._startPos = ce(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate() }, stop: function () { this._inProgress && (this._step(!0), this._complete()) }, _animate: function () { this._animId = w(this._animate, this), this._step() }, _step: function (t) { var e = new Date - this._startTime, n = 1e3 * this._duration; e < n ? this._runFrame(this._easeOut(e / n), t) : (this._runFrame(1), this._complete()) }, _runFrame: function (t, e) { var n = this._startPos.add(this._offset.multiplyBy(t)); e && n._round(), he(this._el, n), this.fire("step") }, _complete: function () { x(this._animId), this._inProgress = !1, this.fire("end") }, _easeOut: function (t) { return 1 - Math.pow(1 - t, this._easeOutPower) } }), Ne = S.extend({ initialize: function (t) { this._map = t }, enable: function () { return this._enabled || (this._enabled = !0, this.addHooks()), this }, disable: function () { return this._enabled && (this._enabled = !1, this.removeHooks()), this }, enabled: function () { return !!this._enabled } }); Ne.addTo = function (t, e) { return t.addHandler(e, this), this }; var De, Be = { Events: M }, Fe = yt ? "touchstart mousedown" : "mousedown", qe = { mousedown: "mouseup", touchstart: "touchend", pointerdown: "touchend", MSPointerDown: "touchend" }, Ge = { mousedown: "mousemove", touchstart: "touchmove", pointerdown: "touchmove", MSPointerDown: "touchmove" }, ze = E.extend({ options: { clickTolerance: 3 }, initialize: function (t, e, n, i) { f(this, i), this._element = t, this._dragStartTarget = e || t, this._preventOutline = n }, enable: function () { this._enabled || (be(this._dragStartTarget, Fe, this._onDown, this), this._enabled = !0) }, disable: function () { this._enabled && (ze._dragging === this && this.finishDrag(), xe(this._dragStartTarget, Fe, this._onDown, this), this._enabled = !1, this._moved = !1) }, _onDown: function (t) { if (!t._simulated && this._enabled && (this._moved = !1, !ne(this._element, "leaflet-zoom-anim") && !(ze._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || ((ze._dragging = this)._preventOutline && ge(this._element), de(), Ht(), this._moving)))) { this.fire("down"); var e = t.touches ? t.touches[0] : t, n = _e(this._element); this._startPoint = new O(e.clientX, e.clientY), this._parentScale = ye(n), be(document, Ge[t.type], this._onMove, this), be(document, qe[t.type], this._onUp, this) } }, _onMove: function (t) { if (!t._simulated && this._enabled) if (t.touches && 1 < t.touches.length) this._moved = !0; else { var e = t.touches && 1 === t.touches.length ? t.touches[0] : t, n = new O(e.clientX, e.clientY)._subtract(this._startPoint); (n.x || n.y) && (Math.abs(n.x) + Math.abs(n.y) < this.options.clickTolerance || (n.x /= this._parentScale.x, n.y /= this._parentScale.y, Me(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = ce(this._element).subtract(n), ie(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), ie(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(n), this._moving = !0, x(this._animRequest), this._lastEvent = t, this._animRequest = w(this._updatePosition, this, !0))) } }, _updatePosition: function () { var t = { originalEvent: this._lastEvent }; this.fire("predrag", t), he(this._element, this._newPos), this.fire("drag", t) }, _onUp: function (t) { !t._simulated && this._enabled && this.finishDrag() }, finishDrag: function () { for (var t in re(document.body, "leaflet-dragging"), this._lastTarget && (re(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Ge) xe(document, Ge[t], this._onMove, this), xe(document, qe[t], this._onUp, this); pe(), Jt(), this._moved && this._moving && (x(this._animRequest), this.fire("dragend", { distance: this._newPos.distanceTo(this._startPos) })), this._moving = !1, ze._dragging = !1 } }); function Ue(t, e) { if (!e || !t.length) return t.slice(); var n = e * e; return t = function (t, e) { var n = t.length, i = new (("undefined" == typeof Uint8Array ? "undefined" : In(Uint8Array)) !== void 0 + "" ? Uint8Array : Array)(n); i[0] = i[n - 1] = 1, function t(e, n, i, r, o) { var s, a, u, l = 0; for (a = r + 1; a <= o - 1; a++)u = Ve(e[a], e[r], e[o], !0), l < u && (s = a, l = u); i < l && (n[s] = 1, t(e, n, i, r, s), t(e, n, i, s, o)) }(t, i, e, 0, n - 1); var r, o = []; for (r = 0; r < n; r++)i[r] && o.push(t[r]); return o }(t = function (t, e) { for (var n = [t[0]], i = 1, r = 0, o = t.length; i < o; i++)s = t[i], a = t[r], 0, u = a.x - s.x, l = a.y - s.y, e < u * u + l * l && (n.push(t[i]), r = i); var s, a, u, l; r < o - 1 && n.push(t[o - 1]); return n }(t, n), n) } function We(t, e, n) { return Math.sqrt(Ve(t, e, n, !0)) } function He(t, e, n, i, r) { var o, s, a, u = i ? De : Ze(t, n), l = Ze(e, n); for (De = l; ;) { if (!(u | l)) return [t, e]; if (u & l) return !1; a = Ze(s = Je(t, e, o = u || l, n, r), n), o === u ? (t = s, u = a) : (e = s, l = a) } } function Je(t, e, n, i, r) { var o, s, a = e.x - t.x, u = e.y - t.y, l = i.min, h = i.max; return 8 & n ? (o = t.x + a * (h.y - t.y) / u, s = h.y) : 4 & n ? (o = t.x + a * (l.y - t.y) / u, s = l.y) : 2 & n ? (o = h.x, s = t.y + u * (h.x - t.x) / a) : 1 & n && (o = l.x, s = t.y + u * (l.x - t.x) / a), new O(o, s, r) } function Ze(t, e) { var n = 0; return t.x < e.min.x ? n |= 1 : t.x > e.max.x && (n |= 2), t.y < e.min.y ? n |= 4 : t.y > e.max.y && (n |= 8), n } function Ve(t, e, n, i) { var r, o = e.x, s = e.y, a = n.x - o, u = n.y - s, l = a * a + u * u; return 0 < l && (1 < (r = ((t.x - o) * a + (t.y - s) * u) / l) ? (o = n.x, s = n.y) : 0 < r && (o += a * r, s += u * r)), a = t.x - o, u = t.y - s, i ? a * a + u * u : new O(o, s) } function Ye(t) { return !g(t[0]) || "object" !== In(t[0][0]) && void 0 !== t[0][0] } function Xe(t) { return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), Ye(t) } var Qe = (Object.freeze || Object)({ simplify: Ue, pointToSegmentDistance: We, closestPointOnSegment: function (t, e, n) { return Ve(t, e, n) }, clipSegment: He, _getEdgeIntersection: Je, _getBitCode: Ze, _sqClosestPointOnSegment: Ve, isFlat: Ye, _flat: Xe }); function $e(t, e, n) { var i, r, o, s, a, u, l, h, c, f = [1, 4, 2, 8]; for (r = 0, l = t.length; r < l; r++)t[r]._code = Ze(t[r], e); for (s = 0; s < 4; s++) { for (h = f[s], i = [], r = 0, o = (l = t.length) - 1; r < l; o = r++)a = t[r], u = t[o], a._code & h ? u._code & h || ((c = Je(u, a, h, e, n))._code = Ze(c, e), i.push(c)) : (u._code & h && ((c = Je(u, a, h, e, n))._code = Ze(c, e), i.push(c)), i.push(a)); t = i } return t } var Ke, tn = (Object.freeze || Object)({ clipPolygon: $e }), en = { project: function (t) { return new O(t.lng, t.lat) }, unproject: function (t) { return new R(t.y, t.x) }, bounds: new k([-180, -90], [180, 90]) }, nn = { R: 6378137, R_MINOR: 6356752.314245179, bounds: new k([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project: function (t) { var e = Math.PI / 180, n = this.R, i = t.lat * e, r = this.R_MINOR / n, o = Math.sqrt(1 - r * r), s = o * Math.sin(i), a = Math.tan(Math.PI / 4 - i / 2) / Math.pow((1 - s) / (1 + s), o / 2); return i = -n * Math.log(Math.max(a, 1e-10)), new O(t.lng * e * n, i) }, unproject: function (t) { for (var e, n = 180 / Math.PI, i = this.R, r = this.R_MINOR / i, o = Math.sqrt(1 - r * r), s = Math.exp(-t.y / i), a = Math.PI / 2 - 2 * Math.atan(s), u = 0, l = .1; u < 15 && 1e-7 < Math.abs(l); u++)e = o * Math.sin(a), e = Math.pow((1 - e) / (1 + e), o / 2), a += l = Math.PI / 2 - 2 * Math.atan(s * e) - a; return new R(a * n, t.x * n / i) } }, rn = (Object.freeze || Object)({ LonLat: en, Mercator: nn, SphericalMercator: q }), on = u({}, F, { code: "EPSG:3395", projection: nn, transformation: z(Ke = .5 / (Math.PI * nn.R), .5, -Ke, .5) }), sn = u({}, F, { code: "EPSG:4326", projection: en, transformation: z(1 / 180, 1, -1 / 180, .5) }), an = u({}, B, { projection: en, transformation: z(1, 0, -1, 0), scale: function (t) { return Math.pow(2, t) }, zoom: function (t) { return Math.log(t) / Math.LN2 }, distance: function (t, e) { var n = e.lng - t.lng, i = e.lat - t.lat; return Math.sqrt(n * n + i * i) }, infinite: !0 }); B.Earth = F, B.EPSG3395 = on, B.EPSG3857 = W, B.EPSG900913 = H, B.EPSG4326 = sn, B.Simple = an; var un = E.extend({ options: { pane: "overlayPane", attribution: null, bubblingMouseEvents: !0 }, addTo: function (t) { return t.addLayer(this), this }, remove: function () { return this.removeFrom(this._map || this._mapToAdd) }, removeFrom: function (t) { return t && t.removeLayer(this), this }, getPane: function (t) { return this._map.getPane(t ? this.options[t] || t : this.options.pane) }, addInteractiveTarget: function (t) { return this._map._targets[l(t)] = this }, removeInteractiveTarget: function (t) { return delete this._map._targets[l(t)], this }, getAttribution: function () { return this.options.attribution }, _layerAdd: function (t) { var e = t.target; if (e.hasLayer(this)) { if (this._map = e, this._zoomAnimated = e._zoomAnimated, this.getEvents) { var n = this.getEvents(); e.on(n, this), this.once("remove", function () { e.off(n, this) }, this) } this.onAdd(e), this.getAttribution && e.attributionControl && e.attributionControl.addAttribution(this.getAttribution()), this.fire("add"), e.fire("layeradd", { layer: this }) } } }), ln = un.extend({ initialize: function (t, e) { var n, i; if (f(this, e), this._layers = {}, t) for (n = 0, i = t.length; n < i; n++)this.addLayer(t[n]) }, addLayer: function (t) { var e = this.getLayerId(t); return this._layers[e] = t, this._map && this._map.addLayer(t), this }, removeLayer: function (t) { var e = t in this._layers ? t : this.getLayerId(t); return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this }, hasLayer: function (t) { return !!t && (t in this._layers || this.getLayerId(t) in this._layers) }, clearLayers: function () { return this.eachLayer(this.removeLayer, this) }, invoke: function (t) { var e, n, i = Array.prototype.slice.call(arguments, 1); for (e in this._layers) (n = this._layers[e])[t] && n[t].apply(n, i); return this }, onAdd: function (t) { this.eachLayer(t.addLayer, t) }, onRemove: function (t) { this.eachLayer(t.removeLayer, t) }, eachLayer: function (t, e) { for (var n in this._layers) t.call(e, this._layers[n]); return this }, getLayer: function (t) { return this._layers[t] }, getLayers: function () { var t = []; return this.eachLayer(t.push, t), t }, setZIndex: function (t) { return this.invoke("setZIndex", t) }, getLayerId: function (t) { return l(t) } }), hn = ln.extend({ addLayer: function (t) { return this.hasLayer(t) ? this : (t.addEventParent(this), ln.prototype.addLayer.call(this, t), this.fire("layeradd", { layer: t })) }, removeLayer: function (t) { return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), ln.prototype.removeLayer.call(this, t), this.fire("layerremove", { layer: t })) : this }, setStyle: function (t) { return this.invoke("setStyle", t) }, bringToFront: function () { return this.invoke("bringToFront") }, bringToBack: function () { return this.invoke("bringToBack") }, getBounds: function () { var t = new A; for (var e in this._layers) { var n = this._layers[e]; t.extend(n.getBounds ? n.getBounds() : n.getLatLng()) } return t } }), cn = S.extend({ options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0] }, initialize: function (t) { f(this, t) }, createIcon: function (t) { return this._createIcon("icon", t) }, createShadow: function (t) { return this._createIcon("shadow", t) }, _createIcon: function (t, e) { var n = this._getIconUrl(t); if (!n) { if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs)."); return null } var i = this._createImg(n, e && "IMG" === e.tagName ? e : null); return this._setIconStyles(i, t), i }, _setIconStyles: function (t, e) { var n = this.options, i = n[e + "Size"]; "number" == typeof i && (i = [i, i]); var r = I(i), o = I("shadow" === e && n.shadowAnchor || n.iconAnchor || r && r.divideBy(2, !0)); t.className = "leaflet-marker-" + e + " " + (n.className || ""), o && (t.style.marginLeft = -o.x + "px", t.style.marginTop = -o.y + "px"), r && (t.style.width = r.x + "px", t.style.height = r.y + "px") }, _createImg: function (t, e) { return (e = e || document.createElement("img")).src = t, e }, _getIconUrl: function (t) { return wt && this.options[t + "RetinaUrl"] || this.options[t + "Url"] } }); var fn = cn.extend({ options: { iconUrl: "marker-icon.png", iconRetinaUrl: "marker-icon-2x.png", shadowUrl: "marker-shadow.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], tooltipAnchor: [16, -28], shadowSize: [41, 41] }, _getIconUrl: function (t) { return fn.imagePath || (fn.imagePath = this._detectIconPath()), (this.options.imagePath || fn.imagePath) + cn.prototype._getIconUrl.call(this, t) }, _detectIconPath: function () { var t = te("div", "leaflet-default-icon-path", document.body), e = Kt(t, "background-image") || Kt(t, "backgroundImage"); return document.body.removeChild(t), e = null === e || 0 !== e.indexOf("url") ? "" : e.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, "") } }), dn = Ne.extend({ initialize: function (t) { this._marker = t }, addHooks: function () { var t = this._marker._icon; this._draggable || (this._draggable = new ze(t, t, !0)), this._draggable.on({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).enable(), ie(t, "leaflet-marker-draggable") }, removeHooks: function () { this._draggable.off({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).disable(), this._marker._icon && re(this._marker._icon, "leaflet-marker-draggable") }, moved: function () { return this._draggable && this._draggable._moved }, _adjustPan: function (t) { var e = this._marker, n = e._map, i = this._marker.options.autoPanSpeed, r = this._marker.options.autoPanPadding, o = ce(e._icon), s = n.getPixelBounds(), a = n.getPixelOrigin(), u = C(s.min._subtract(a).add(r), s.max._subtract(a).subtract(r)); if (!u.contains(o)) { var l = I((Math.max(u.max.x, o.x) - u.max.x) / (s.max.x - u.max.x) - (Math.min(u.min.x, o.x) - u.min.x) / (s.min.x - u.min.x), (Math.max(u.max.y, o.y) - u.max.y) / (s.max.y - u.max.y) - (Math.min(u.min.y, o.y) - u.min.y) / (s.min.y - u.min.y)).multiplyBy(i); n.panBy(l, { animate: !1 }), this._draggable._newPos._add(l), this._draggable._startPos._add(l), he(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = w(this._adjustPan.bind(this, t)) } }, _onDragStart: function () { this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup().fire("movestart").fire("dragstart") }, _onPreDrag: function (t) { this._marker.options.autoPan && (x(this._panRequest), this._panRequest = w(this._adjustPan.bind(this, t))) }, _onDrag: function (t) { var e = this._marker, n = e._shadow, i = ce(e._icon), r = e._map.layerPointToLatLng(i); n && he(n, i), e._latlng = r, t.latlng = r, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t) }, _onDragEnd: function (t) { x(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t) } }), pn = un.extend({ options: { icon: new fn, interactive: !0, keyboard: !0, title: "", alt: "", zIndexOffset: 0, opacity: 1, riseOnHover: !1, riseOffset: 250, pane: "markerPane", bubblingMouseEvents: !1, draggable: !1, autoPan: !1, autoPanPadding: [50, 50], autoPanSpeed: 10 }, initialize: function (t, e) { f(this, e), this._latlng = N(t) }, onAdd: function (t) { this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update() }, onRemove: function (t) { this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow() }, getEvents: function () { return { zoom: this.update, viewreset: this.update } }, getLatLng: function () { return this._latlng }, setLatLng: function (t) { var e = this._latlng; return this._latlng = N(t), this.update(), this.fire("move", { oldLatLng: e, latlng: this._latlng }) }, setZIndexOffset: function (t) { return this.options.zIndexOffset = t, this.update() }, setIcon: function (t) { return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this }, getElement: function () { return this._icon }, update: function () { if (this._icon && this._map) { var t = this._map.latLngToLayerPoint(this._latlng).round(); this._setPos(t) } return this }, _initIcon: function () { var t = this.options, e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), n = t.icon.createIcon(this._icon), i = !1; n !== this._icon && (this._icon && this._removeIcon(), i = !0, t.title && (n.title = t.title), "IMG" === n.tagName && (n.alt = t.alt || "")), ie(n, e), t.keyboard && (n.tabIndex = "0"), this._icon = n, t.riseOnHover && this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }); var r = t.icon.createShadow(this._shadow), o = !1; r !== this._shadow && (this._removeShadow(), o = !0), r && (ie(r, e), r.alt = ""), this._shadow = r, t.opacity < 1 && this._updateOpacity(), i && this.getPane().appendChild(this._icon), this._initInteraction(), r && o && this.getPane("shadowPane").appendChild(this._shadow) }, _removeIcon: function () { this.options.riseOnHover && this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), ee(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null }, _removeShadow: function () { this._shadow && ee(this._shadow), this._shadow = null }, _setPos: function (t) { he(this._icon, t), this._shadow && he(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex() }, _updateZIndex: function (t) { this._icon.style.zIndex = this._zIndex + t }, _animateZoom: function (t) { var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round(); this._setPos(e) }, _initInteraction: function () { if (this.options.interactive && (ie(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), dn)) { var t = this.options.draggable; this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new dn(this), t && this.dragging.enable() } }, setOpacity: function (t) { return this.options.opacity = t, this._map && this._updateOpacity(), this }, _updateOpacity: function () { var t = this.options.opacity; ae(this._icon, t), this._shadow && ae(this._shadow, t) }, _bringToFront: function () { this._updateZIndex(this.options.riseOffset) }, _resetZIndex: function () { this._updateZIndex(0) }, _getPopupAnchor: function () { return this.options.icon.options.popupAnchor }, _getTooltipAnchor: function () { return this.options.icon.options.tooltipAnchor } }); var gn = un.extend({ options: { stroke: !0, color: "#3388ff", weight: 3, opacity: 1, lineCap: "round", lineJoin: "round", dashArray: null, dashOffset: null, fill: !1, fillColor: null, fillOpacity: .2, fillRule: "evenodd", interactive: !0, bubblingMouseEvents: !0 }, beforeAdd: function (t) { this._renderer = t.getRenderer(this) }, onAdd: function () { this._renderer._initPath(this), this._reset(), this._renderer._addPath(this) }, onRemove: function () { this._renderer._removePath(this) }, redraw: function () { return this._map && this._renderer._updatePath(this), this }, setStyle: function (t) { return f(this, t), this._renderer && this._renderer._updateStyle(this), this }, bringToFront: function () { return this._renderer && this._renderer._bringToFront(this), this }, bringToBack: function () { return this._renderer && this._renderer._bringToBack(this), this }, getElement: function () { return this._path }, _reset: function () { this._project(), this._update() }, _clickTolerance: function () { return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance } }), mn = gn.extend({ options: { fill: !0, radius: 10 }, initialize: function (t, e) { f(this, e), this._latlng = N(t), this._radius = this.options.radius }, setLatLng: function (t) { return this._latlng = N(t), this.redraw(), this.fire("move", { latlng: this._latlng }) }, getLatLng: function () { return this._latlng }, setRadius: function (t) { return this.options.radius = this._radius = t, this.redraw() }, getRadius: function () { return this._radius }, setStyle: function (t) { var e = t && t.radius || this._radius; return gn.prototype.setStyle.call(this, t), this.setRadius(e), this }, _project: function () { this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds() }, _updateBounds: function () { var t = this._radius, e = this._radiusY || t, n = this._clickTolerance(), i = [t + n, e + n]; this._pxBounds = new k(this._point.subtract(i), this._point.add(i)) }, _update: function () { this._map && this._updatePath() }, _updatePath: function () { this._renderer._updateCircle(this) }, _empty: function () { return this._radius && !this._renderer._bounds.intersects(this._pxBounds) }, _containsPoint: function (t) { return t.distanceTo(this._point) <= this._radius + this._clickTolerance() } }); var _n = mn.extend({ initialize: function (t, e, n) { if ("number" == typeof e && (e = u({}, n, { radius: e })), f(this, e), this._latlng = N(t), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN"); this._mRadius = this.options.radius }, setRadius: function (t) { return this._mRadius = t, this.redraw() }, getRadius: function () { return this._mRadius }, getBounds: function () { var t = [this._radius, this._radiusY || this._radius]; return new A(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t))) }, setStyle: gn.prototype.setStyle, _project: function () { var t = this._latlng.lng, e = this._latlng.lat, n = this._map, i = n.options.crs; if (i.distance === F.distance) { var r = Math.PI / 180, o = this._mRadius / F.R / r, s = n.project([e + o, t]), a = n.project([e - o, t]), u = s.add(a).divideBy(2), l = n.unproject(u).lat, h = Math.acos((Math.cos(o * r) - Math.sin(e * r) * Math.sin(l * r)) / (Math.cos(e * r) * Math.cos(l * r))) / r; !isNaN(h) && 0 !== h || (h = o / Math.cos(Math.PI / 180 * e)), this._point = u.subtract(n.getPixelOrigin()), this._radius = isNaN(h) ? 0 : u.x - n.project([l, t - h]).x, this._radiusY = u.y - s.y } else { var c = i.unproject(i.project(this._latlng).subtract([this._mRadius, 0])); this._point = n.latLngToLayerPoint(this._latlng), this._radius = this._point.x - n.latLngToLayerPoint(c).x } this._updateBounds() } }); var yn = gn.extend({ options: { smoothFactor: 1, noClip: !1 }, initialize: function (t, e) { f(this, e), this._setLatLngs(t) }, getLatLngs: function () { return this._latlngs }, setLatLngs: function (t) { return this._setLatLngs(t), this.redraw() }, isEmpty: function () { return !this._latlngs.length }, closestLayerPoint: function (t) { for (var e, n, i = 1 / 0, r = null, o = Ve, s = 0, a = this._parts.length; s < a; s++)for (var u = this._parts[s], l = 1, h = u.length; l < h; l++) { var c = o(t, e = u[l - 1], n = u[l], !0); c < i && (i = c, r = o(t, e, n)) } return r && (r.distance = Math.sqrt(i)), r }, getCenter: function () { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); var t, e, n, i, r, o, s, a = this._rings[0], u = a.length; if (!u) return null; for (e = t = 0; t < u - 1; t++)e += a[t].distanceTo(a[t + 1]) / 2; if (0 === e) return this._map.layerPointToLatLng(a[0]); for (i = t = 0; t < u - 1; t++)if (r = a[t], o = a[t + 1], e < (i += n = r.distanceTo(o))) return s = (i - e) / n, this._map.layerPointToLatLng([o.x - s * (o.x - r.x), o.y - s * (o.y - r.y)]) }, getBounds: function () { return this._bounds }, addLatLng: function (t, e) { return e = e || this._defaultShape(), t = N(t), e.push(t), this._bounds.extend(t), this.redraw() }, _setLatLngs: function (t) { this._bounds = new A, this._latlngs = this._convertLatLngs(t) }, _defaultShape: function () { return Ye(this._latlngs) ? this._latlngs : this._latlngs[0] }, _convertLatLngs: function (t) { for (var e = [], n = Ye(t), i = 0, r = t.length; i < r; i++)n ? (e[i] = N(t[i]), this._bounds.extend(e[i])) : e[i] = this._convertLatLngs(t[i]); return e }, _project: function () { var t = new k; this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t); var e = this._clickTolerance(), n = new O(e, e); this._bounds.isValid() && t.isValid() && (t.min._subtract(n), t.max._add(n), this._pxBounds = t) }, _projectLatlngs: function (t, e, n) { var i, r, o = t[0] instanceof R, s = t.length; if (o) { for (r = [], i = 0; i < s; i++)r[i] = this._map.latLngToLayerPoint(t[i]), n.extend(r[i]); e.push(r) } else for (i = 0; i < s; i++)this._projectLatlngs(t[i], e, n) }, _clipPoints: function () { var t = this._renderer._bounds; if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else { var e, n, i, r, o, s, a, u = this._parts; for (i = e = 0, r = this._rings.length; e < r; e++)for (n = 0, o = (a = this._rings[e]).length; n < o - 1; n++)(s = He(a[n], a[n + 1], t, n, !0)) && (u[i] = u[i] || [], u[i].push(s[0]), s[1] === a[n + 1] && n !== o - 2 || (u[i].push(s[1]), i++)) } }, _simplifyPoints: function () { for (var t = this._parts, e = this.options.smoothFactor, n = 0, i = t.length; n < i; n++)t[n] = Ue(t[n], e) }, _update: function () { this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath()) }, _updatePath: function () { this._renderer._updatePoly(this) }, _containsPoint: function (t, e) { var n, i, r, o, s, a, u = this._clickTolerance(); if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (n = 0, o = this._parts.length; n < o; n++)for (i = 0, r = (s = (a = this._parts[n]).length) - 1; i < s; r = i++)if ((e || 0 !== i) && We(t, a[r], a[i]) <= u) return !0; return !1 } }); yn._flat = Xe; var vn = yn.extend({ options: { fill: !0 }, isEmpty: function () { return !this._latlngs.length || !this._latlngs[0].length }, getCenter: function () { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); var t, e, n, i, r, o, s, a, u, l = this._rings[0], h = l.length; if (!h) return null; for (o = s = a = 0, t = 0, e = h - 1; t < h; e = t++)n = l[t], i = l[e], r = n.y * i.x - i.y * n.x, s += (n.x + i.x) * r, a += (n.y + i.y) * r, o += 3 * r; return u = 0 === o ? l[0] : [s / o, a / o], this._map.layerPointToLatLng(u) }, _convertLatLngs: function (t) { var e = yn.prototype._convertLatLngs.call(this, t), n = e.length; return 2 <= n && e[0] instanceof R && e[0].equals(e[n - 1]) && e.pop(), e }, _setLatLngs: function (t) { yn.prototype._setLatLngs.call(this, t), Ye(this._latlngs) && (this._latlngs = [this._latlngs]) }, _defaultShape: function () { return Ye(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0] }, _clipPoints: function () { var t = this._renderer._bounds, e = this.options.weight, n = new O(e, e); if (t = new k(t.min.subtract(n), t.max.add(n)), this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var i, r = 0, o = this._rings.length; r < o; r++)(i = $e(this._rings[r], t, !0)).length && this._parts.push(i) }, _updatePath: function () { this._renderer._updatePoly(this, !0) }, _containsPoint: function (t) { var e, n, i, r, o, s, a, u, l = !1; if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (r = 0, a = this._parts.length; r < a; r++)for (o = 0, s = (u = (e = this._parts[r]).length) - 1; o < u; s = o++)n = e[o], i = e[s], n.y > t.y != i.y > t.y && t.x < (i.x - n.x) * (t.y - n.y) / (i.y - n.y) + n.x && (l = !l); return l || yn.prototype._containsPoint.call(this, t, !0) } }); var bn = hn.extend({ initialize: function (t, e) { f(this, e), this._layers = {}, t && this.addData(t) }, addData: function (t) { var e, n, i, r = g(t) ? t : t.features; if (r) { for (e = 0, n = r.length; e < n; e++)((i = r[e]).geometries || i.geometry || i.features || i.coordinates) && this.addData(i); return this } var o = this.options; if (o.filter && !o.filter(t)) return this; var s = function t(e, n) { var i, r, o, s, a = "Feature" === e.type ? e.geometry : e, u = a ? a.coordinates : null, l = [], h = n && n.pointToLayer, c = n && n.coordsToLatLng || wn; if (!u && !a) return null; switch (a.type) { case "Point": return i = c(u), h ? h(e, i) : new pn(i); case "MultiPoint": for (o = 0, s = u.length; o < s; o++)i = c(u[o]), l.push(h ? h(e, i) : new pn(i)); return new hn(l); case "LineString": case "MultiLineString": return r = xn(u, "LineString" === a.type ? 0 : 1, c), new yn(r, n); case "Polygon": case "MultiPolygon": return r = xn(u, "Polygon" === a.type ? 1 : 2, c), new vn(r, n); case "GeometryCollection": for (o = 0, s = a.geometries.length; o < s; o++) { var f = t({ geometry: a.geometries[o], type: "Feature", properties: e.properties }, n); f && l.push(f) } return new hn(l); default: throw new Error("Invalid GeoJSON object.") } }(t, o); return s ? (s.feature = Mn(t), s.defaultOptions = s.options, this.resetStyle(s), o.onEachFeature && o.onEachFeature(t, s), this.addLayer(s)) : this }, resetStyle: function (t) { return t.options = u({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this }, setStyle: function (e) { return this.eachLayer(function (t) { this._setLayerStyle(t, e) }, this) }, _setLayerStyle: function (t, e) { "function" == typeof e && (e = e(t.feature)), t.setStyle && t.setStyle(e) } }); function wn(t) { return new R(t[1], t[0], t[2]) } function xn(t, e, n) { for (var i, r = [], o = 0, s = t.length; o < s; o++)i = e ? xn(t[o], e - 1, n) : (n || wn)(t[o]), r.push(i); return r } function Ln(t, e) { return e = "number" == typeof e ? e : 6, void 0 !== t.alt ? [s(t.lng, e), s(t.lat, e), s(t.alt, e)] : [s(t.lng, e), s(t.lat, e)] } function Pn(t, e, n, i) { for (var r = [], o = 0, s = t.length; o < s; o++)r.push(e ? Pn(t[o], e - 1, n, i) : Ln(t[o], i)); return !e && n && r.push(r[0]), r } function Sn(t, e) { return t.feature ? u({}, t.feature, { geometry: e }) : Mn(e) } function Mn(t) { return "Feature" === t.type || "FeatureCollection" === t.type ? t : { type: "Feature", properties: {}, geometry: t } } var En = { toGeoJSON: function (t) { return Sn(this, { type: "Point", coordinates: Ln(this.getLatLng(), t) }) } }; function On(t, e) { return new bn(t, e) } pn.include(En), _n.include(En), mn.include(En), yn.include({ toGeoJSON: function (t) { var e = !Ye(this._latlngs); return Sn(this, { type: (e ? "Multi" : "") + "LineString", coordinates: Pn(this._latlngs, e ? 1 : 0, !1, t) }) } }), vn.include({ toGeoJSON: function (t) { var e = !Ye(this._latlngs), n = e && !Ye(this._latlngs[0]), i = Pn(this._latlngs, n ? 2 : e ? 1 : 0, !0, t); return e || (i = [i]), Sn(this, { type: (n ? "Multi" : "") + "Polygon", coordinates: i }) } }), ln.include({ toMultiPoint: function (e) { var n = []; return this.eachLayer(function (t) { n.push(t.toGeoJSON(e).geometry.coordinates) }), Sn(this, { type: "MultiPoint", coordinates: n }) }, toGeoJSON: function (i) { var t = this.feature && this.feature.geometry && this.feature.geometry.type; if ("MultiPoint" === t) return this.toMultiPoint(i); var r = "GeometryCollection" === t, o = []; return this.eachLayer(function (t) { if (t.toGeoJSON) { var e = t.toGeoJSON(i); if (r) o.push(e.geometry); else { var n = Mn(e); "FeatureCollection" === n.type ? o.push.apply(o, n.features) : o.push(n) } } }), r ? Sn(this, { geometries: o, type: "GeometryCollection" }) : { type: "FeatureCollection", features: o } } }); var Tn = On; Object.freeze = e, t.version = "1.3.4", t.Browser = Mt, t.Evented = E, t.Mixin = Be, t.Util = P, t.Class = S, t.Handler = Ne, t.extend = u, t.bind = p, t.stamp = l, t.setOptions = f, t.DomEvent = je, t.DomUtil = ve, t.PosAnimation = Re, t.Draggable = ze, t.LineUtil = Qe, t.PolyUtil = tn, t.Point = O, t.point = I, t.Bounds = k, t.bounds = C, t.Transformation = G, t.transformation = z, t.Projection = rn, t.LatLng = R, t.latLng = N, t.LatLngBounds = A, t.latLngBounds = j, t.CRS = B, t.GeoJSON = bn, t.geoJSON = On, t.geoJson = Tn, window.L || (window.L = t) }, "object" === In(e) && void 0 !== t ? s(e) : (r = [e], void 0 === (o = "function" == typeof (i = s) ? i.apply(e, r) : i) || (t.exports = o)) }, function (t, e) { t.exports = n }, function (t, e, n) { "use strict"; var i, r, o, s, a = "function" == typeof Symbol && "symbol" === _typeof2(Symbol.iterator) ? function (t) { return _typeof2(t) } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof2(t) }; s = function (t, c) { var e = window.XMLHttpRequest && "withCredentials" in new window.XMLHttpRequest, a = { cors: e, pointerEvents: "" === document.documentElement.style.pointerEvents }, n = { attributionWidthOffset: 55 }, s = 0; function u(t) { var e = ""; for (var n in t.f = t.f || "json", t) if (t.hasOwnProperty(n)) { var i, r = t[n], o = Object.prototype.toString.call(r); e.length && (e += "&"), i = "[object Array]" === o ? "[object Object]" === Object.prototype.toString.call(r[0]) ? JSON.stringify(r) : r.join(",") : "[object Object]" === o ? JSON.stringify(r) : "[object Date]" === o ? r.valueOf() : r, e += encodeURIComponent(n) + "=" + encodeURIComponent(i) } return e } function l(i, r) { var o = new window.XMLHttpRequest; return o.onerror = function (t) { o.onreadystatechange = c.Util.falseFn, i.call(r, { error: { code: 500, message: "XMLHttpRequest error" } }, null) }, o.onreadystatechange = function () { var e, n; if (4 === o.readyState) { try { e = JSON.parse(o.responseText) } catch (t) { e = null, n = { code: 500, message: "Could not parse response as JSON. This could also be caused by a CORS or XMLHttpRequest error." } } !n && e.error && (n = e.error, e = null), o.onerror = c.Util.falseFn, i.call(r, n, e) } }, o.ontimeout = function () { this.onerror() }, o } function i(t, e, n, i) { var r = l(n, i); return r.open("POST", t), null != i && void 0 !== i.options && (r.timeout = i.options.timeout), r.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"), r.send(u(e)), r } function r(t, e, n, i) { var r = l(n, i); return r.open("GET", t + "?" + u(e), !0), null != i && void 0 !== i.options && (r.timeout = i.options.timeout), r.send(null), r } function o(t, e, n, i) { var r = u(e), o = l(n, i), s = (t + "?" + r).length; if (s <= 2e3 && a.cors ? o.open("GET", t + "?" + r) : 2e3 < s && a.cors && (o.open("POST", t), o.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")), null != i && void 0 !== i.options && (o.timeout = i.options.timeout), s <= 2e3 && a.cors) o.send(null); else { if (!(2e3 < s && a.cors)) return s <= 2e3 && !a.cors ? h(t, e, n, i) : void R("a request to " + t + " was longer then 2000 characters and this browser cannot make a cross-domain post request. Please use a proxy http://esri.github.io/esri-leaflet/api-reference/request.html"); o.send(r) } return o } function h(t, e, i, r) { window._EsriLeafletCallbacks = window._EsriLeafletCallbacks || {}; var o = "c" + s; e.callback = "window._EsriLeafletCallbacks." + o, window._EsriLeafletCallbacks[o] = function (t) { if (!0 !== window._EsriLeafletCallbacks[o]) { var e, n = Object.prototype.toString.call(t); "[object Object]" !== n && "[object Array]" !== n && (e = { error: { code: 500, message: "Expected array or object as JSONP response" } }, t = null), !e && t.error && (e = t, t = null), i.call(r, e, t), window._EsriLeafletCallbacks[o] = !0 } }; var n = c.DomUtil.create("script", null, document.body); return n.type = "text/javascript", n.src = t + "?" + u(e), n.id = o, c.DomUtil.addClass(n, "esri-leaflet-jsonp"), s++, { id: o, url: n.src, abort: function () { window._EsriLeafletCallbacks._callback[o]({ code: 0, message: "Request aborted." }) } } } var f = a.cors ? r : h; f.CORS = r, f.JSONP = h; var d = { request: o, get: f, post: i }; function p(t) { return function (t, e) { for (var n = 0; n < t.length; n++)if (t[n] !== e[n]) return; return 1 }(t[0], t[t.length - 1]) || t.push(t[0]), t } function g(t) { for (var e, n = 0, i = 0, r = t.length, o = t[i]; i < r - 1; i++)n += ((e = t[i + 1])[0] - o[0]) * (e[1] + o[1]), o = e; return 0 <= n } function m(t, e, n, i) { var r = (i[0] - n[0]) * (t[1] - n[1]) - (i[1] - n[1]) * (t[0] - n[0]), o = (e[0] - t[0]) * (t[1] - n[1]) - (e[1] - t[1]) * (t[0] - n[0]), s = (i[1] - n[1]) * (e[0] - t[0]) - (i[0] - n[0]) * (e[1] - t[1]); if (0 != s) { var a = r / s, u = o / s; if (0 <= a && a <= 1 && 0 <= u && u <= 1) return 1 } } function _(t, e) { for (var n = 0; n < t.length - 1; n++)for (var i = 0; i < e.length - 1; i++)if (m(t[n], t[n + 1], e[i], e[i + 1])) return !0; return !1 } function y(t, e) { var n = _(t, e), i = function (t, e) { for (var n = !1, i = -1, r = t.length, o = r - 1; ++i < r; o = i)(t[i][1] <= e[1] && e[1] < t[o][1] || t[o][1] <= e[1] && e[1] < t[i][1]) && e[0] < (t[o][0] - t[i][0]) * (e[1] - t[i][1]) / (t[o][1] - t[i][1]) + t[i][0] && (n = !n); return n }(t, e[0]); return !(n || !i) } function v(t) { var e = [], n = t.slice(0), i = p(n.shift().slice(0)); if (4 <= i.length) { g(i) || i.reverse(), e.push(i); for (var r = 0; r < n.length; r++) { var o = p(n[r].slice(0)); 4 <= o.length && (g(o) && o.reverse(), e.push(o)) } } return e } function b(t) { var e = {}; for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]); return e } function w(t, e) { var n = {}; if ("number" == typeof t.x && "number" == typeof t.y && (n.type = "Point", n.coordinates = [t.x, t.y], "number" == typeof t.z && n.coordinates.push(t.z)), t.points && (n.type = "MultiPoint", n.coordinates = t.points.slice(0)), t.paths && (1 === t.paths.length ? (n.type = "LineString", n.coordinates = t.paths[0].slice(0)) : (n.type = "MultiLineString", n.coordinates = t.paths.slice(0))), t.rings && (n = function (t) { for (var e, n, i = [], r = [], o = 0; o < t.length; o++) { var s = p(t[o].slice(0)); if (!(s.length < 4)) if (g(s)) { var a = [s.slice().reverse()]; i.push(a) } else r.push(s.slice().reverse()) } for (var u = []; r.length;) { n = r.pop(); var l = !1; for (e = i.length - 1; 0 <= e; e--)if (y(i[e][0], n)) { i[e].push(n), l = !0; break } l || u.push(n) } for (; u.length;) { n = u.pop(); var h = !1; for (e = i.length - 1; 0 <= e; e--)if (_(i[e][0], n)) { i[e].push(n), h = !0; break } h || i.push([n.reverse()]) } return 1 === i.length ? { type: "Polygon", coordinates: i[0] } : { type: "MultiPolygon", coordinates: i } }(t.rings.slice(0))), (t.geometry || t.attributes) && (n.type = "Feature", n.geometry = t.geometry ? w(t.geometry) : null, n.properties = t.attributes ? b(t.attributes) : null, t.attributes)) try { n.id = function (t, e) { for (var n = e ? [e, "OBJECTID", "FID"] : ["OBJECTID", "FID"], i = 0; i < n.length; i++) { var r = n[i]; if (r in t && ("string" == typeof t[r] || "number" == typeof t[r])) return t[r] } throw Error("No valid id attribute found") }(t.attributes, e) } catch (t) { } return JSON.stringify(n.geometry) === JSON.stringify({}) && (n.geometry = null), t.spatialReference && t.spatialReference.wkid && 4326 !== t.spatialReference.wkid && console.warn("Object converted in non-standard crs - " + JSON.stringify(t.spatialReference)), n } function x(t, e) { e = e || "OBJECTID"; var n, i = { wkid: 4326 }, r = {}; switch (t.type) { case "Point": r.x = t.coordinates[0], r.y = t.coordinates[1], r.spatialReference = i; break; case "MultiPoint": r.points = t.coordinates.slice(0), r.spatialReference = i; break; case "LineString": r.paths = [t.coordinates.slice(0)], r.spatialReference = i; break; case "MultiLineString": r.paths = t.coordinates.slice(0), r.spatialReference = i; break; case "Polygon": r.rings = v(t.coordinates.slice(0)), r.spatialReference = i; break; case "MultiPolygon": r.rings = function (t) { for (var e = [], n = 0; n < t.length; n++)for (var i = v(t[n]), r = i.length - 1; 0 <= r; r--) { var o = i[r].slice(0); e.push(o) } return e }(t.coordinates.slice(0)), r.spatialReference = i; break; case "Feature": t.geometry && (r.geometry = x(t.geometry, e)), r.attributes = t.properties ? b(t.properties) : {}, t.id && (r.attributes[e] = t.id); break; case "FeatureCollection": for (r = [], n = 0; n < t.features.length; n++)r.push(x(t.features[n], e)); break; case "GeometryCollection": for (r = [], n = 0; n < t.geometries.length; n++)r.push(x(t.geometries[n], e)) }return r } function L(t, e) { return x(t, e) } function P(t, e) { return w(t, e) } function S(t) { if ("NaN" === t.xmin || "NaN" === t.ymin || "NaN" === t.xmax || "NaN" === t.ymax) return null; var e = c.latLng(t.ymin, t.xmin), n = c.latLng(t.ymax, t.xmax); return c.latLngBounds(e, n) } function M(t) { return { xmin: (t = c.latLngBounds(t)).getSouthWest().lng, ymin: t.getSouthWest().lat, xmax: t.getNorthEast().lng, ymax: t.getNorthEast().lat, spatialReference: { wkid: 4326 } } } var E = /^(OBJECTID|FID|OID|ID)$/i; function O(t) { var e; if (t.objectIdFieldName) e = t.objectIdFieldName; else if (t.fields) { for (var n = 0; n <= t.fields.length - 1; n++)if ("esriFieldTypeOID" === t.fields[n].type) { e = t.fields[n].name; break } if (!e) for (n = 0; n <= t.fields.length - 1; n++)if (t.fields[n].name.match(E)) { e = t.fields[n].name; break } } return e } function T(t) { for (var e in t.attributes) if (e.match(E)) return e } function I(t, e) { var n, i = t.features || t.results, r = i.length; n = e || O(t); var o = { type: "FeatureCollection", features: [] }; if (r) for (var s = i.length - 1; 0 <= s; s--) { var a = P(i[s], n || T(i[s])); o.features.push(a) } return o } function k(t) { return "/" !== (t = c.Util.trim(t))[t.length - 1] && (t += "/"), t } function C(t) { if (-1 !== t.url.indexOf("?")) { t.requestParams = t.requestParams || {}; var e = t.url.substring(t.url.indexOf("?") + 1); t.url = t.url.split("?")[0], t.requestParams = JSON.parse('{"' + decodeURI(e).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}') } return t.url = k(t.url.split("?")[0]), t } function A(t) { return /^(?!.*utility\.arcgis\.com).*\.arcgis\.com.*FeatureServer/i.test(t) } function j(t) { var e; switch (t) { case "Point": e = "esriGeometryPoint"; break; case "MultiPoint": e = "esriGeometryMultipoint"; break; case "LineString": case "MultiLineString": e = "esriGeometryPolyline"; break; case "Polygon": case "MultiPolygon": e = "esriGeometryPolygon" }return e } function R() { console && console.warn && console.warn.apply(console, arguments) } function N(t) { return t.getSize().x - n.attributionWidthOffset + "px" } function D(t) { var e = { geometry: null, geometryType: null }; return t instanceof c.LatLngBounds ? (e.geometry = M(t), e.geometryType = "esriGeometryEnvelope", e) : (t.getLatLng && (t = t.getLatLng()), t instanceof c.LatLng && (t = { type: "Point", coordinates: [t.lng, t.lat] }), t instanceof c.GeoJSON && (t = t.getLayers()[0].feature.geometry, e.geometry = L(t), e.geometryType = j(t.type)), t.toGeoJSON && (t = t.toGeoJSON()), "Feature" === t.type && (t = t.geometry), "Point" === t.type || "LineString" === t.type || "Polygon" === t.type || "MultiPolygon" === t.type ? (e.geometry = L(t), e.geometryType = j(t.type), e) : void R("invalid geometry passed to spatial query. Should be L.LatLng, L.LatLngBounds, L.Marker or a GeoJSON Point, Line, Polygon or MultiPolygon object")) } function B(t) { var e = t.target, n = e._esriAttributions; if (e && e.attributionControl && n) { for (var i = "", r = e.getBounds(), o = c.latLngBounds(r.getSouthWest().wrap(), r.getNorthEast().wrap()), s = e.getZoom(), a = 0; a < n.length; a++) { var u = n[a], l = u.attribution; !i.match(l) && u.bounds.intersects(o) && s >= u.minZoom && s <= u.maxZoom && (i += ", " + l) } i = i.substr(2); var h = e.attributionControl._container.querySelector(".esri-dynamic-attribution"); h.innerHTML = i, h.style.maxWidth = N(e), e.fire("attributionupdated", { attribution: i }) } } var F = { warn: R, cleanUrl: k, getUrlParams: C, isArcgisOnline: A, geojsonTypeToArcGIS: j, responseToFeatureCollection: I, geojsonToArcGIS: L, arcgisToGeoJSON: P, boundsToExtent: M, extentToBounds: S, calcAttributionWidth: N, setEsriAttribution: function (e) { if (e.attributionControl && !e.attributionControl._esriAttributionAdded) { e.attributionControl.setPrefix('<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a> | Powered by <a href="https://www.esri.com">Esri</a>'); var n = document.createElement("style"); n.type = "text/css", n.innerHTML = ".esri-truncated-attribution:hover {white-space: normal;}", document.getElementsByTagName("head")[0].appendChild(n), c.DomUtil.addClass(e.attributionControl._container, "esri-truncated-attribution:hover"); var i = document.createElement("style"); i.type = "text/css", i.innerHTML = ".esri-truncated-attribution {vertical-align: -3px;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;display: inline-block;transition: 0s white-space;transition-delay: 1s;max-width: " + N(e) + ";}", document.getElementsByTagName("head")[0].appendChild(i), c.DomUtil.addClass(e.attributionControl._container, "esri-truncated-attribution"), e.on("resize", function (t) { e.attributionControl._container.style.maxWidth = N(t.target) }), e.on("unload", function () { n.parentNode.removeChild(n), i.parentNode.removeChild(i); for (var t = document.querySelectorAll(".esri-leaflet-jsonp"), e = 0; e < t.length; e++)t.item(e).parentNode.removeChild(t.item(e)) }), e.attributionControl._esriAttributionAdded = !0 } }, _setGeometry: D, _getAttributionData: function (t, u) { h(t, {}, c.Util.bind(function (t, e) { if (!t) { u._esriAttributions = []; for (var n = 0; n < e.contributors.length; n++)for (var i = e.contributors[n], r = 0; r < i.coverageAreas.length; r++) { var o = i.coverageAreas[r], s = c.latLng(o.bbox[0], o.bbox[1]), a = c.latLng(o.bbox[2], o.bbox[3]); u._esriAttributions.push({ attribution: i.attribution, score: o.score, bounds: c.latLngBounds(s, a), minZoom: o.zoomMin, maxZoom: o.zoomMax }) } u._esriAttributions.sort(function (t, e) { return e.score - t.score }), B({ target: u }) } }, this)) }, _updateMapAttribution: B, _findIdAttributeFromFeature: T, _findIdAttributeFromResponse: O }, q = c.Class.extend({ options: { proxy: !1, useCors: e }, generateSetter: function (e, t) { return c.Util.bind(function (t) { return this.params[e] = t, this }, t) }, initialize: function (t) { if (t.request && t.options ? (this._service = t, c.Util.setOptions(this, t.options)) : (c.Util.setOptions(this, t), this.options.url = k(t.url)), this.params = c.Util.extend({}, this.params || {}), this.setters) for (var e in this.setters) { var n = this.setters[e]; this[e] = this.generateSetter(n, this) } }, token: function (t) { return this._service ? this._service.authenticate(t) : this.params.token = t, this }, format: function (t) { return this.params.returnUnformattedValues = !t, this }, request: function (t, e) { return this.options.requestParams && c.Util.extend(this.params, this.options.requestParams), this._service ? this._service.request(this.path, this.params, t, e) : this._request("request", this.path, this.params, t, e) }, _request: function (t, e, n, i, r) { var o = this.options.proxy ? this.options.proxy + "?" + this.options.url + e : this.options.url + e; return "get" !== t && "request" !== t || this.options.useCors ? d[t](o, n, i, r) : d.get.JSONP(o, n, i, r) } }); var G = q.extend({ setters: { offset: "resultOffset", limit: "resultRecordCount", fields: "outFields", precision: "geometryPrecision", featureIds: "objectIds", returnGeometry: "returnGeometry", returnM: "returnM", transform: "datumTransformation", token: "token" }, path: "query", params: { returnGeometry: !0, where: "1=1", outSr: 4326, outFields: "*" }, within: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelContains", this }, intersects: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelIntersects", this }, contains: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelWithin", this }, crosses: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelCrosses", this }, touches: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelTouches", this }, overlaps: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelOverlaps", this }, bboxIntersects: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelEnvelopeIntersects", this }, indexIntersects: function (t) { return this._setGeometryParams(t), this.params.spatialRel = "esriSpatialRelIndexIntersects", this }, nearby: function (t, e) { return t = c.latLng(t), this.params.geometry = [t.lng, t.lat], this.params.geometryType = "esriGeometryPoint", this.params.spatialRel = "esriSpatialRelIntersects", this.params.units = "esriSRUnit_Meter", this.params.distance = e, this.params.inSr = 4326, this }, where: function (t) { return this.params.where = t, this }, between: function (t, e) { return this.params.time = [t.valueOf(), e.valueOf()], this }, simplify: function (t, e) { var n = Math.abs(t.getBounds().getWest() - t.getBounds().getEast()); return this.params.maxAllowableOffset = n / t.getSize().y * e, this }, orderBy: function (t, e) { return e = e || "ASC", this.params.orderByFields = this.params.orderByFields ? this.params.orderByFields + "," : "", this.params.orderByFields += [t, e].join(" "), this }, run: function (n, i) { return this._cleanParams(), this.options.isModern || A(this.options.url) ? (this.params.f = "geojson", this.request(function (t, e) { this._trapSQLerrors(t), n.call(i, t, e, e) }, this)) : this.request(function (t, e) { this._trapSQLerrors(t), n.call(i, t, e && I(e), e) }, this) }, count: function (n, t) { return this._cleanParams(), this.params.returnCountOnly = !0, this.request(function (t, e) { n.call(this, t, e && e.count, e) }, t) }, ids: function (n, t) { return this._cleanParams(), this.params.returnIdsOnly = !0, this.request(function (t, e) { n.call(this, t, e && e.objectIds, e) }, t) }, bounds: function (n, i) { return this._cleanParams(), this.params.returnExtentOnly = !0, this.request(function (t, e) { e && e.extent && S(e.extent) ? n.call(i, t, S(e.extent), e) : (t = { message: "Invalid Bounds" }, n.call(i, t, null, e)) }, i) }, distinct: function () { return this.params.returnGeometry = !1, this.params.returnDistinctValues = !0, this }, pixelSize: function (t) { var e = c.point(t); return this.params.pixelSize = [e.x, e.y], this }, layer: function (t) { return this.path = t + "/query", this }, _trapSQLerrors: function (t) { t && "400" === t.code && R("one common syntax error in query requests is encasing string values in double quotes instead of single quotes") }, _cleanParams: function () { delete this.params.returnIdsOnly, delete this.params.returnExtentOnly, delete this.params.returnCountOnly }, _setGeometryParams: function (t) { this.params.inSr = 4326; var e = D(t); this.params.geometry = e.geometry, this.params.geometryType = e.geometryType } }); var z = q.extend({ setters: { contains: "contains", text: "searchText", fields: "searchFields", spatialReference: "sr", sr: "sr", layers: "layers", returnGeometry: "returnGeometry", maxAllowableOffset: "maxAllowableOffset", precision: "geometryPrecision", dynamicLayers: "dynamicLayers", returnZ: "returnZ", returnM: "returnM", gdbVersion: "gdbVersion", token: "token" }, path: "find", params: { sr: 4326, contains: !0, returnGeometry: !0, returnZ: !0, returnM: !1 }, layerDefs: function (t, e) { return this.params.layerDefs = this.params.layerDefs ? this.params.layerDefs + ";" : "", this.params.layerDefs += [t, e].join(":"), this }, simplify: function (t, e) { var n = Math.abs(t.getBounds().getWest() - t.getBounds().getEast()); return this.params.maxAllowableOffset = n / t.getSize().y * e, this }, run: function (n, i) { return this.request(function (t, e) { n.call(i, t, e && I(e), e) }, i) } }); var U = q.extend({ path: "identify", between: function (t, e) { return this.params.time = [t.valueOf(), e.valueOf()], this } }); t.VERSION = "2.1.4", t.Support = a, t.options = n, t.Util = F, t.get = f, t.post = i, t.request = o, t.Task = q, t.task = function (t) { return t = C(t), new q(t) }, t.Query = G, t.query = function (t) { return new G(t) }, t.Find = z, t.find = function (t) { return new z(t) }, t.Identify = U, t.identify = function (t) { return new U(t) } }, "object" === a(e) && void 0 !== t ? s(e, n(0)) : (r = [e, n(0)], void 0 === (o = "function" == typeof (i = s) ? i.apply(e, r) : i) || (t.exports = o)) }, function (t, e, n) { "use strict"; a(n(1)); var i = a(n(0)), r = a(n(2)), o = n(4), s = n(5); function a(t) { return t && t.__esModule ? t : { default: t } } window.gsp3d || console.log("请首先引入 cesium-mars 基础库，才能使用该插件！ http://www.dehui.info"), gsp3d.L = i.default, gsp3d.L.esri = r.default, gsp3d.layer.ArcFeatureLayer = o.ArcFeatureLayer, gsp3d.layer.regLayerForConfig("arcgis_feature2", o.ArcFeatureLayer), gsp3d.layer.ArcFeatureGridLayer = s.ArcFeatureGridLayer, gsp3d.layer.regLayerForConfig("arcgis_feature", s.ArcFeatureGridLayer) }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.ArcFeatureLayer = void 0; var a = r(n(1)), i = (r(n(0)), r(n(2))); function r(t) { return t && t.__esModule ? t : { default: t } } var o = gsp3d.layer.GeoJsonLayer.extend({ queryData: function () { this.dataSource && (this.viewer.dataSources.remove(this.dataSource), this.dataSource = null); var s = this, t = this.config.url; this.config.layers && 0 < this.config.layers.length && (t += "/" + this.config.layers[0]); var e = i.default.query({ url: t }); this.config.where && e.where(this.config.where), e.run(function (t, e, n) { if (null != t && 0 < t.code) gsp3d.util.alert(t.message, "服务访问出错"); else if (null != e && null != e && 0 != e.features.length) { for (var i = [], r = 0; r < e.features.length; r++) { var o = e.features[r]; null != o && null != o.geometry && (o.geometry.coordinates && 0 == o.geometry.coordinates.length || i.push(o)) } e.features = i, a.default.GeoJsonDataSource.load(e, { clampToGround: !0 }).then(function (t) { s.showResult(t) }).otherwise(function (t) { s.showError("服务出错", t) }) } else gsp3d.util.msg("未找到符合查询条件的要素！") }) }, setWhere: function (t) { this.config.where = t, this.queryData() } }); e.ArcFeatureLayer = o }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.ArcFeatureGridLayer = void 0; var o = i(n(1)), s = i(n(0)), a = i(n(2)); function i(t) { return t && t.__esModule ? t : { default: t } } var r = gsp3d.layer.CustomFeatureGridLayer.extend({ getDataForGrid: function (i, r) { var o = this, t = this.config.url; this.config.layers && 0 < this.config.layers.length && (t += "/" + this.config.layers[0]); var e = a.default.query({ url: t }), n = s.default.latLngBounds(s.default.latLng(i.rectangle.ymin, i.rectangle.xmin), s.default.latLng(i.rectangle.ymax, i.rectangle.xmax)); e.within(n), this.config.where && e.where(this.config.where), e.run(function (t, e, n) { o._visible && o._cacheGrid[i.key] && (null != t && 0 < t.code ? console.log("arcgis服务访问出错" + t.message) : null != e && null != e && ("Feature" == e.type && (e = { type: "FeatureCollection", features: [e] }), r(e.features))) }) }, createEntity: function (n, t, i) { var r = this; return o.default.GeoJsonDataSource.load(t, { clampToGround: !0 }).then(function (t) { if (!r.checkHasBreak[n.key]) { if (0 == t.entities.values.length) return null; var e = t.entities.values[0]; e._id = r.config.id + "_" + n.key + "_" + e.id, r._addEntity(e, i) } }).otherwise(function (t) { r.showError("服务出错", t) }), null }, _addEntity: function (t, e) { var n = this, i = this.config.symbol; i && ("function" == typeof i ? i(t, t.properties) : "default" == i ? this.setDefSymbol(t) : this.setConfigSymbol(t, i)), (this.config.columns || this.config.popup) && (t.popup = { html: function (t) { return n.viewer.mars.popup.getPopupForConfig(n.config, t.properties) }, anchor: this.config.popupAnchor || [0, -15] }), this.config.tooltip && (t.tooltip = { html: function (t) { return n.viewer.mars.popup.getPopupForConfig({ popup: n.config.tooltip }, t.properties) }, anchor: this.config.tooltipAnchor || [0, -15] }), this.dataSource.entities.add(t), e(t) }, setWhere: function (t) { this.config.where = t, this.reload() } }); e.ArcFeatureGridLayer = r }], i.c = o, i.d = function (t, e, n) { i.o(t, e) || Object.defineProperty(t, e, { configurable: !1, enumerable: !0, get: n }) }, i.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return i.d(e, "a", e), e }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, i.p = "", i(i.s = 3); function i(t) { if (o[t]) return o[t].exports; var e = o[t] = { i: t, l: !1, exports: {} }; return r[t].call(e.exports, e, e.exports, i), e.l = !0, e.exports } var r, o });